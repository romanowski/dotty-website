<html><head><meta charset="utf-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><title>Implicit Function Types</title><script type="text/javascript" src="../../scripts/clipboard.js" defer="true"></script><script type="text/javascript" src="../../scripts/platform-content-handler.js" defer="true"></script><script type="text/javascript" src="../../scripts/main.js" defer="true"></script><link rel="stylesheet" href="../../styles/nord-light.css"></link><link rel="stylesheet" href="../../styles/scalastyle.css"></link><link rel="stylesheet" href="../../styles/dotty-icons.css"></link><link rel="stylesheet" href="../../styles/diagram.css"></link><link rel="stylesheet" href="../../styles/filter-bar.css"></link><link rel="stylesheet" href="../../styles/search-bar.css"></link><script type="text/javascript" src="https://code.jquery.com/jquery-3.5.1.min.js" defer="true"></script><script type="text/javascript" src="https://d3js.org/d3.v6.min.js" defer="true"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/graphlib-dot@0.6.2/dist/graphlib-dot.min.js" defer="true"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/dagre-d3/0.6.1/dagre-d3.min.js" defer="true"></script><script type="text/javascript" src="../../scripts/diagram.js" defer="true"></script><link rel="stylesheet" href="../../styles/filter-bar.css"></link><script type="text/javascript" src="../../hljs/highlight.pack.js" defer="true"></script><script type="text/javascript" src="../../scripts/hljs-scala3.js" defer="true"></script><script type="text/javascript" src="../../scripts/ux.js" defer="true"></script><script type="text/javascript" src="../../scripts/common/component.js" defer="true"></script><script type="text/javascript" src="../../scripts/common/utils.js" defer="true"></script><script type="text/javascript" src="../../scripts/components/FilterBar.js" defer="true"></script><script type="text/javascript" src="../../scripts/components/DocumentableList.js" defer="true"></script><script type="text/javascript" src="../../scripts/components/Input.js" defer="true"></script><script type="text/javascript" src="../../scripts/components/FilterGroup.js" defer="true"></script><script type="text/javascript" src="../../scripts/components/Filter.js" defer="true"></script><script type="text/javascript" src="../../scripts/data.js" defer="true"></script><script type="text/javascript" src="../../scripts/fast-navigation-loader.js" defer="true"></script><link rel="stylesheet" href="../../css/bootstrap.min.css"></link><link rel="stylesheet" href="../../css/dottydoc.css"></link><link rel="stylesheet" href="../../css/color-brewer.css"></link><script type="text/javascript" src="../../js/jquery.min.js" defer="true"></script><script type="text/javascript" src="../../js/bootstrap.min.js" defer="true"></script><script>var pathToRoot = "../../";</script></head><body><div id="container"><div id="leftColumn"><div id="logo"></div><div id="paneSearch"></div><nav id="sideMenu"></nav></div><div id="main"><div id="leftToggler"><span class="icon-toggler"></span></div><div id="searchBar"></div><main>
  <div id="content" pageIds="_.blog/_posts/2016-12-05-implicit-function-types.md////PointingToDeclaration//-1542669386">
    <div class="breadcrumbs"><a href="../index.html"></a>/<a href="index.html">Blog</a>/<a href="../-blog/2016-12-05-implicit-function-types.html">Implicit Function Types</a></div>
<html>
 <head>
  <link rel="dns-prefetch" href="//fonts.googleapis.com"> 
  <link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin> 
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin> 
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.9.0/css/all.min.css"> 
 </head>
 <body>
  <div id="content-wrapper"> 
   <main class="container"> 
    <header> 
     <h1>Implicit Function Types</h1> 
     <div class="byline"> <time class="date"> <i class="far fa-calendar-alt"></i> 2016-12-05 </time> <span class="author"> <i class="fas fa-pen-nib"></i> Martin Odersky </span> 
     </div> 
    </header> 
    <p>I just made the <a href="https://github.com/lampepfl/dotty/pull/1775">first pull request</a> to add <em>implicit function types</em> to Scala. I am pretty excited about it, because - citing the explanation of the pull request - "<em>This is the first step to bring contextual abstraction to Scala</em>". What do I mean by this?</p> 
    <p><strong>Abstraction</strong>: The ability to name a concept and use just the name afterwards.</p> 
    <p><strong>Contextual</strong>: A piece of a program produces results or outputs in some context. Our programming languages are very good at describing and abstracting what outputs are produced. But there's hardly anything yet available to abstract over the inputs that programs get from their context. Many interesting scenarios fall into that category, including:</p> 
    <ul> 
     <li>passing configuration data to the parts of a system that need them,</li> 
     <li>managing capabilities for security critical tasks,</li> 
     <li>wiring components up with dependency injection,</li> 
     <li>defining the meanings of operations with type classes,</li> 
     <li>more generally, passing any sort of context to a computation.</li> 
    </ul> 
    <p>Implicit function types are a surprisingly simple and general way to make coding patterns solving these tasks abstractable, reducing boilerplate code and increasing applicability.</p> 
    <p><strong>First Step</strong>: My pull request is a first implementation. It solves the problem in principle, but introduces some run-time overhead. The next step will be to eliminate the run-time overhead through some simple optimizations.</p> 
    <h2>Implicit Parameters</h2> 
    <p>In a functional setting, the inputs to a computation are most naturally expressed as <em>parameters</em>. One could simply augment functions to take additional parameters that represent configurations, capabilities, dictionaries, or whatever contextual data the functions need. The only downside with this is that often there's a large distance in the call graph between the definition of a contextual element and the site where it is used. Consequently, it becomes tedious to define all those intermediate parameters and to pass them along to where they are eventually consumed.</p> 
    <p>Implicit parameters solve one half of the problem. Implicit parameters do not have to be propagated using boilerplate code; the compiler takes care of that. This makes them practical in many scenarios where plain parameters would be too cumbersome. For instance, type classes would be a lot less popular if one would have to pass all dictionaries by hand. Implicit parameters are also very useful as a general context passing mechanism. For instance in the <em>Dotty</em> compiler, almost every function takes an implicit context parameter which defines all elements relating to the current state of the compilation. This is in my experience much better than the cake pattern because it is lightweight and can express context changes in a purely functional way.</p> 
    <p>The main downside of implicit parameters is the verbosity of their declaration syntax. It's hard to illustrate this with a smallish example, because it really only becomes a problem at scale, but let's try anyway.</p> 
    <p>Let's say we want to write some piece of code that's designed to run in a transaction. For the sake of illustration here's a simple transaction class:</p> 
    <pre><code class="language-scala">class Transaction {
  private val log = new ListBuffer[String]
  def println(s: String): Unit = log += s

  private var aborted = false
  private var committed = false

  def abort(): Unit = { aborted = true }
  def isAborted = aborted

  def commit(): Unit =
    if (!aborted &amp;&amp; !committed) {
      Console.println("******* log ********")
      log.foreach(Console.println)
      committed = true
    }
}
</code></pre> 
    <p>The transaction encapsulates a log, to which one can print messages. It can be in one of three states: running, committed, or aborted. If the transaction is committed, it prints the stored log to the console.</p> 
    <p>The <code>transaction</code> method lets one run some given code <code>op</code> inside a newly created transaction:</p> 
    <pre><code class="language-scala">  def transaction[T](op: Transaction =&gt; T) = {
    val trans: Transaction = new Transaction
    op(trans)
    trans.commit()
  }
</code></pre> 
    <p>The current transaction needs to be passed along a call chain to all the places that need to access it. To illustrate this, here are three functions <code>f1</code>, <code>f2</code> and <code>f3</code> which call each other, and also access the current transaction. The most convenient way to achieve this is by passing the current transaction as an implicit parameter.</p> 
    <pre><code class="language-scala">  def f1(x: Int)(implicit thisTransaction: Transaction): Int = {
    thisTransaction.println(s"first step: $x")
    f2(x + 1)
  }
  def f2(x: Int)(implicit thisTransaction: Transaction): Int = {
    thisTransaction.println(s"second step: $x")
    f3(x * x)
  }
  def f3(x: Int)(implicit thisTransaction: Transaction): Int = {
    thisTransaction.println(s"third step: $x")
    if (x % 2 != 0) thisTransaction.abort()
    x
  }
</code></pre> 
    <p>The main program calls <code>f1</code> in a fresh transaction context and prints its result:</p> 
    <pre><code class="language-scala">  def main(args: Array[String]) = {
    transaction {
      implicit thisTransaction =&gt;
        val res = f1(args.length)
        println(if (thisTransaction.isAborted) "aborted" else s"result: $res")
    }
  }
</code></pre> 
    <p>Two sample calls of the program (let's call it <code>TransactionDemo</code>) are here:</p> 
    <pre><code class="language-shell">scala TransactionDemo 1 2 3
result: 16
******* log ********
first step: 3
second step: 4
third step: 16

scala TransactionDemo 1 2 3 4
aborted
</code></pre> 
    <p>So far, so good. The code above is quite compact as far as expressions are concerned. In particular, it's nice that, being implicit parameters, none of the transaction values had to be passed along explicitly in a call. But on the definition side, things are less rosy: Every one of the functions <code>f1</code> to <code>f3</code> needed an additional implicit parameter:</p> 
    <pre><code class="language-scala">(implicit thisTransaction: Transaction)
</code></pre> 
    <p>A three-times repetition might not look so bad here, but it certainly smells of boilerplate. In real-sized projects, this can get much worse. For instance, the <em>Dotty</em> compiler uses implicit abstraction over contexts for most of its parts. Consequently it ends up with currently no fewer than 2641 occurrences of the text string</p> 
    <pre><code class="language-scala">(implicit ctx: Context)
</code></pre> 
    <p>It would be nice if we could get rid of them.</p> 
    <h2>Implicit Functions</h2> 
    <p>Let's massage the definition of <code>f1</code> a bit by moving the last parameter section to the right of the equals sign:</p> 
    <pre><code class="language-scala">  def f1(x: Int) = { implicit thisTransaction: Transaction =&gt;
    thisTransaction.println(s"first step: $x")
    f2(x + 1)
  }
</code></pre> 
    <p>The right hand side of this new version of <code>f1</code> is now an implicit function value. What's the type of this value? Previously, it was <code>Transaction =&gt; Int</code>, that is, the knowledge that the function has an implicit parameter got lost in the type. The main extension implemented by the pull request is to introduce implicit function types that mirror the implicit function values which we have already. Concretely, the new type of <code>f1</code> is:</p> 
    <pre><code class="language-scala">implicit Transaction =&gt; Int
</code></pre> 
    <p>Just like the normal function type syntax <code>A =&gt; B</code>, desugars to <code>scala.Function1[A, B]</code> the implicit function type syntax <code>implicit A =&gt; B</code> desugars to <code>scala.ImplicitFunction1[A, B]</code>. The same holds at other function arities. With Dotty's <a href="https://github.com/lampepfl/dotty/pull/1758">pull request #1758</a> merged there is no longer an upper limit of 22 for such functions.</p> 
    <p>The type <code>ImplicitFunction1</code> can be thought of being defined as follows:</p> 
    <pre><code class="language-scala">trait ImplicitFunction1[-T0, R] extends Function1[T0, R] {
  override def apply(implicit x: T0): R
}
</code></pre> 
    <p>However, you won't find a classfile for this trait because all implicit function traits get mapped to normal functions during type erasure.</p> 
    <p>There are two rules that guide type checking of implicit function types. The first rule says that an implicit function is applied to implicit arguments in the same way an implicit method is. More precisely, if <code>t</code> is an expression of an implicit function type</p> 
    <pre><code class="language-scala">t: implicit (T1, ..., Tn) =&gt; R
</code></pre> 
    <p>such that <code>t</code> is not an implicit closure itself and <code>t</code> is not the prefix of a call <code>t.apply(...)</code>, then an <code>apply</code> is implicitly inserted, so <code>t</code> becomes <code>t.apply</code>. We have already seen that the definition of <code>t.apply</code> is an implicit method as given in the corresponding implicit function trait. Hence, it will in turn be applied to a matching sequence of implicit arguments. The end effect is that references to implicit functions get applied to implicit arguments in the same way as references to implicit methods.</p> 
    <p>The second rule is the dual of the first. If the expected type of an expression <code>t</code> is an implicit function type</p> 
    <pre><code class="language-scala">implicit (T1, ..., Tn) =&gt; R
</code></pre> 
    <p>then <code>t</code> is converted to an implicit closure, unless it is already one. More precisely, <code>t</code> is mapped to the implicit closure</p> 
    <pre><code class="language-scala">implicit ($ev1: T1, ..., $evn: Tn) =&gt; t
</code></pre> 
    <p>The parameter names of this closure are compiler-generated identifiers which should not be accessed from user code. That is, the only way to refer to an implicit parameter of a compiler-generated function is via <code>implicitly</code>.</p> 
    <p>It is important to note that this second conversion needs to be applied <em>before</em> the expression <code>t</code> is typechecked. This is because the conversion establishes the necessary context to make type checking <code>t</code> succeed by defining the required implicit parameters.</p> 
    <p>There is one final tweak to make this all work: When using implicit parameters for nested functions it was so far important to give all implicit parameters of the same type the same name, or else one would get ambiguities. For instance, consider the following fragment:</p> 
    <pre><code class="language-scala">def f(implicit c: C) = {
  def g(implicit c: C) = ... implicitly[C] ...
  ...
}
</code></pre> 
    <p>If we had named the inner parameter <code>d</code> instead of <code>c</code> we would have gotten an implicit ambiguity at the call of <code>implicitly</code> because both <code>c</code> and <code>d</code> would be eligible:</p> 
    <pre><code class="language-scala">def f(implicit c: C) = {
  def g(implicit d: C) = ... implicitly[C] ... // error!
  ...
}
</code></pre> 
    <p>The problem is that parameters in implicit closures now have compiler-generated names, so the programmer cannot enforce the proper naming scheme to avoid all ambiguities. We fix the problem by introducing a new disambiguation rule which makes nested occurrences of an implicit take precedence over outer ones. This rule, which applies to all implicit parameters and implicit locals, is conceptually analogous to the rule that prefers implicits defined in companion objects of subclasses over those defined in companion objects of superclass. With that new disambiguation rule the example code above now compiles.</p> 
    <p>That's the complete set of rules needed to deal with implicit function types.</p> 
    <h2>How to Remove Boilerplate</h2> 
    <p>The main advantage of implicit function types is that, being types, they can be abstracted. That is, one can define a name for an implicit function type and then use just the name instead of the full type. Let's revisit our previous example and see how it can be made more concise using this technique.</p> 
    <p>We first define a type <code>Transactional</code> for functions that take an implicit parameter of type <code>Transaction</code>:</p> 
    <pre><code class="language-scala">type Transactional[T] = implicit Transaction =&gt; T
</code></pre> 
    <p>Making the return type of <code>f1</code> to <code>f3</code> a <code>Transactional[Int]</code>, we can eliminate their implicit parameter sections:</p> 
    <pre><code class="language-scala">  def f1(x: Int): Transactional[Int] = {
    thisTransaction.println(s"first step: $x")
    f2(x + 1)
  }
  def f2(x: Int): Transactional[Int] = {
    thisTransaction.println(s"second step: $x")
    f3(x * x)
  }
  def f3(x: Int): Transactional[Int] = {
    thisTransaction.println(s"third step: $x")
    if (x % 2 != 0) thisTransaction.abort()
    x
  }
</code></pre> 
    <p>You might ask, how does <code>thisTransaction</code> typecheck, since there is no longer a parameter with that name? In fact, <code>thisTransaction</code> is now a global definition:</p> 
    <pre><code class="language-scala">  def thisTransaction: Transactional[Transaction] = implicitly[Transaction]
</code></pre> 
    <p>You might ask: a <code>Transactional[Transaction]</code>, is that not circular? To see more clearly, let's expand the definition according to the rules given in the last section. <code>thisTransaction</code> is of implicit function type, so the right hand side is expanded to the implicit closure</p> 
    <pre><code class="language-scala">  implicit ($ev0: Transaction) =&gt; implicitly[Transaction]
</code></pre> 
    <p>The right hand side of this closure, <code>implicitly[Transaction]</code>, needs an implicit parameter of type <code>Transaction</code>, so the closure is further expanded to</p> 
    <pre><code class="language-scala">  implicit ($ev0: Transaction) =&gt; implicitly[Transaction]($ev0)
</code></pre> 
    <p>Now, <code>implicitly</code> is defined in <code>scala.Predef</code> like this:</p> 
    <pre><code class="language-scala">  def implicitly[T](implicit x: T) = x
</code></pre> 
    <p>If we plug that definition into the closure above and simplify, we get:</p> 
    <pre><code class="language-scala">  implicit ($ev0: Transaction) =&gt; $ev0
</code></pre> 
    <p>So, <code>thisTransaction</code> is just the implicit identity function on <code>transaction</code>! In other words, if we use <code>thisTransaction</code> in the body of <code>f1</code> to <code>f3</code>, it will pick up and return the unnamed implicit parameter that's in scope.</p> 
    <p>Finally, here are the <code>transaction</code> and <code>main</code> method that complete the example. Since <code>transactional</code>'s parameter <code>op</code> is now a <code>Transactional</code>, we can eliminate the <code>Transaction</code> argument to <code>op</code> and the <code>Transaction</code> lambda in <code>main</code>; both will be added by the compiler.</p> 
    <pre><code class="language-scala">  def transaction[T](op: Transactional[T]) = {
    implicit val trans: Transaction = new Transaction
    op
    trans.commit()
  }
  def main(args: Array[String]) = {
    transaction {
      val res = f1(args.length)
      println(if (thisTransaction.isAborted) "aborted" else s"result: $res")
    }
  }
</code></pre> 
    <h2>Categorically Speaking</h2> 
    <p>There are many interesting connections with category theory to explore here. On the one hand, implicit functions are used for tasks that are sometimes covered with monads such as the reader monad. There's an argument to be made that implicits have better composability than monads and why that is.</p> 
    <p>On the other hand, it turns out that implicit functions can also be given a co-monadic interpretation, and the interplay between monads and comonads is very interesting in its own right.</p> 
    <p>But these discussions will have to wait for another time, as this blog post is already too long.</p> 
    <h2>Conclusion</h2> 
    <p>Implicit function types are unique way to abstract over the context in which some piece of code is run. I believe they will deeply influence the way we write Scala in the future. They are very powerful abstractions, in the sense that just declaring a type of a function will inject certain implicit values into the scope of the function's implementation. Can this be abused, making code more obscure? Absolutely, like every other powerful abstraction technique. To keep your code sane, please keep the <a href="http://www.lihaoyi.com/post/StrategicScalaStylePrincipleofLeastPower.html">Principle of Least Power</a> in mind.</p> 
    <hr> 
    <footer> 
     <img id="author-img" src="images/martin.jpg"> <span id="author-signature"> Martin Odersky </span> 
    </footer> 
   </main> 
  </div> 
  <script>
  ((window.gitter = {}).chat = {}).options = {
    room: 'lampepfl/dotty'
  };
</script> 
  <script src="https://sidecar.gitter.im/dist/sidecar.v1.js" async defer></script>
 </body>
</html>  </div>
</main><footer><span class="go-to-top-icon"><a href="#container"><span class="icon-vertical_align_top"></span>&nbsp;Back to top</a></span><span class="pull-right">Generated by&nbsp;<a href="https://github.com/lampepfl/scala3doc">Scala3doc</a></span></footer></div></div><script type="text/javascript" src="../../scripts/pages.js"></script><script type="text/javascript" src="../../scripts/main.js"></script></body></html>
