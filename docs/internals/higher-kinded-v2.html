<html><head><meta charset="utf-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><title>Higher-Kinded Types in Dotty</title><link rel="shortcut icon" type="image/x-icon" href="../../favicon.ico"></link><script type="text/javascript" src="../../scripts/clipboard.js" defer="true"></script><script type="text/javascript" src="../../scripts/platform-content-handler.js" defer="true"></script><script type="text/javascript" src="../../scripts/main.js" defer="true"></script><link rel="stylesheet" href="../../styles/nord-light.css"></link><link rel="stylesheet" href="../../styles/scalastyle.css"></link><link rel="stylesheet" href="../../styles/dotty-icons.css"></link><link rel="stylesheet" href="../../styles/diagram.css"></link><link rel="stylesheet" href="../../styles/filter-bar.css"></link><link rel="stylesheet" href="../../styles/search-bar.css"></link><script type="text/javascript" src="https://code.jquery.com/jquery-3.5.1.min.js" defer="true"></script><script type="text/javascript" src="https://d3js.org/d3.v6.min.js" defer="true"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/graphlib-dot@0.6.2/dist/graphlib-dot.min.js" defer="true"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/dagre-d3/0.6.1/dagre-d3.min.js" defer="true"></script><script type="text/javascript" src="../../scripts/diagram.js" defer="true"></script><link rel="stylesheet" href="../../styles/filter-bar.css"></link><script type="text/javascript" src="../../hljs/highlight.pack.js" defer="true"></script><script type="text/javascript" src="../../scripts/hljs-scala3.js" defer="true"></script><script type="text/javascript" src="../../scripts/ux.js" defer="true"></script><script type="text/javascript" src="../../scripts/common/component.js" defer="true"></script><script type="text/javascript" src="../../scripts/common/utils.js" defer="true"></script><script type="text/javascript" src="../../scripts/components/FilterBar.js" defer="true"></script><script type="text/javascript" src="../../scripts/components/DocumentableList.js" defer="true"></script><script type="text/javascript" src="../../scripts/components/Input.js" defer="true"></script><script type="text/javascript" src="../../scripts/components/FilterGroup.js" defer="true"></script><script type="text/javascript" src="../../scripts/components/Filter.js" defer="true"></script><script type="text/javascript" src="../../scripts/data.js" defer="true"></script><script type="text/javascript" src="../../scripts/fast-navigation-loader.js" defer="true"></script><link rel="stylesheet" href="../../css/bootstrap.min.css"></link><link rel="stylesheet" href="../../css/dottydoc.css"></link><link rel="stylesheet" href="../../css/color-brewer.css"></link><script type="text/javascript" src="../../js/jquery.min.js" defer="true"></script><script type="text/javascript" src="../../js/bootstrap.min.js" defer="true"></script><script>var pathToRoot = "../../";</script></head><body><div id="container"><div id="leftColumn"><div id="logo"><span><img src="../../project-logo/logo.svg"></img></span><span><div class="projectName">Scala 3</div><div class="projectVersion">3.0.0-M2</div></span></div><div id="paneSearch"></div><nav id="sideMenu"></nav></div><div id="main"><div id="leftToggler"><span class="icon-toggler"></span></div><div id="searchBar"></div><main>
  <div id="content" pageIds="_.docs/internals/higher-kinded-v2.md////PointingToDeclaration//-1490135309">
    <div class="breadcrumbs"><a href="../index.html"></a>/<a href="../Internals/index.html">Internals</a>/<a href="higher-kinded-v2.html">Higher-Kinded Types in Dotty</a></div>
<html>
 <head>
  <link rel="dns-prefetch" href="//fonts.googleapis.com"> 
  <link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin> 
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin> 
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.9.0/css/all.min.css"> 
 </head>
 <body>
  <div id="content-wrapper"> 
   <main class="container"> 
    <header> 
     <h1>"Higher-Kinded Types in Dotty"</h1> 
     <div class="byline"> <a href="https://github.com/lampepfl/dotty/edit/master/docs/docs/internals/higher-kinded-v2.md#L"> <i class="far fa-edit"></i> Edit this page on GitHub </a> 
     </div> 
    </header> 
    <aside class="warning">
      This page is out of date and preserved for posterity. Please see <a href="http://guillaume.martres.me/publications/dotty-hk.pdf"> Implementing Higher-Kinded Types in Dotty</a> for a more up to date version 
    </aside> 
    <h1><a href="#higher-kinded-types-in-dotty-v2" id="higher-kinded-types-in-dotty-v2" class="anchor"></a>Higher-Kinded Types in Dotty V2</h1> 
    <p>This note outlines how we intend to represent higher-kinded types in Dotty. The principal idea is to collapse the four previously disparate features of refinements, type parameters, existentials and higher-kinded types into just one: refinements of type members. All other features will be encoded using these refinements.</p> 
    <p>The complexity of type systems tends to grow exponentially with the number of independent features, because there are an exponential number of possible feature interactions. Consequently, a reduction from 4 to 1 fundamental features achieves a dramatic reduction of complexity. It also adds some nice usablilty improvements, notably in the area of partial type application.</p> 
    <p>This is a second version of the scheme which differs in a key aspect from the first one: Following Adriaan's idea, we use traits with type members to model type lambdas and type applications. This is both more general and more robust than the intersections with type constructor traits that we had in the first version.</p> 
    <h2><a href="#the-duality" id="the-duality" class="anchor"></a>The duality</h2> 
    <p>The core idea: A parameterized class such as</p> 
    <pre><code class="language-scala">class Map[K, V]
</code></pre> 
    <p>is treated as equivalent to a type with type members:</p> 
    <pre><code class="language-scala">class Map { type Map$K; type Map$V }
</code></pre> 
    <p>The type members are name-mangled (i.e. <code>Map$K</code>) so that they do not conflict with other members or parameters named <code>K</code> or <code>V</code>.</p> 
    <p>A type-instance such as <code>Map[String, Int]</code> would then be treated as equivalent to:</p> 
    <pre><code class="language-scala">Map { type Map$K = String; type Map$V = Int }
</code></pre> 
    <h2><a href="#named-type-parameters" id="named-type-parameters" class="anchor"></a>Named type parameters</h2> 
    <p>Type parameters can have unmangled names. This is achieved by adding the <code>type</code> keyword to a type parameter declaration, analogous to how <code>val</code> indicates a named field. For instance,</p> 
    <pre><code class="language-scala">class Map[type K, type V]
</code></pre> 
    <p>is treated as equivalent to</p> 
    <pre><code class="language-scala">class Map { type K; type V }
</code></pre> 
    <p>The parameters are made visible as fields.</p> 
    <h2><a href="#wildcards" id="wildcards" class="anchor"></a>Wildcards</h2> 
    <p>A wildcard type such as <code>Map[_, Int]</code> is equivalent to:</p> 
    <pre><code class="language-scala">Map { type Map$V = Int }
</code></pre> 
    <p>I.e. <code>_</code>'s omit parameters from being instantiated. Wildcard arguments can have bounds. E.g.</p> 
    <pre><code class="language-scala">Map[_ &lt;: AnyRef, Int]
</code></pre> 
    <p>is equivalent to:</p> 
    <pre><code class="language-scala">Map { type Map$K &lt;: AnyRef; type Map$V = Int }
</code></pre> 
    <h2><a href="#type-parameters-in-the-encodings" id="type-parameters-in-the-encodings" class="anchor"></a>Type parameters in the encodings</h2> 
    <p>The notion of type parameters makes sense even for encoded types, which do not contain parameter lists in their syntax. Specifically, the type parameters of a type are a sequence of type fields that correspond to parameters in the unencoded type. They are determined as follows.</p> 
    <ul> 
     <li>The type parameters of a class or trait type are those parameter fields declared in the class that are not yet instantiated, in the order they are given. Type parameter fields of parents are not considered.</li> 
     <li>The type parameters of an abstract type are the type parameters of its upper bound.</li> 
     <li>The type parameters of an alias type are the type parameters of its right hand side.</li> 
     <li>The type parameters of every other type is the empty sequence.</li> 
    </ul> 
    <h2><a href="#partial-applications" id="partial-applications" class="anchor"></a>Partial applications</h2> 
    <p>The definition of type parameters in the previous section leads to a simple model of partial applications. Consider for instance:</p> 
    <pre><code class="language-scala">type Histogram = Map[_, Int]
</code></pre> 
    <p><code>Histogram</code> is a higher-kinded type that still has one type parameter. <code>Histogram[String]</code> would be a possible type instance, and it would be equivalent to <code>Map[String, Int]</code>.</p> 
    <h2><a href="#modelling-polymorphic-type-declarations" id="modelling-polymorphic-type-declarations" class="anchor"></a>Modelling polymorphic type declarations</h2> 
    <p>The partial application scheme gives us a new -- and quite elegant -- way to do certain higher-kinded types. But how do we interprete the poymorphic types that exist in current Scala?</p> 
    <p>More concretely, current Scala allows us to write parameterized type definitions, abstract types, and type parameters. In the new scheme, only classes (and traits) can have parameters and these are treated as equivalent to type members. Type aliases and abstract types do not allow the definition of parameterized types so we have to interprete polymorphic type aliases and abstract types specially.</p> 
    <h2><a href="#modelling-polymorphic-type-aliases-simple-case" id="modelling-polymorphic-type-aliases-simple-case" class="anchor"></a>Modelling polymorphic type aliases: simple case</h2> 
    <p>A polymorphic type alias such as:</p> 
    <pre><code class="language-scala">type Pair[T] = Tuple2[T, T]
</code></pre> 
    <p>where <code>Tuple2</code> is declared as</p> 
    <pre><code class="language-scala">class Tuple2[T1, T2] ...
</code></pre> 
    <p>is expanded to a monomorphic type alias like this:</p> 
    <pre><code class="language-scala">type Pair = Tuple2 { type Tuple2$T2 = Tuple2$T1 }
</code></pre> 
    <p>More generally, each type parameter of the left-hand side must appear as a type member of the right hand side type. Type members must appear in the same order as their corresponding type parameters. References to the type parameter are then translated to references to the type member. The type member itself is left uninstantiated.</p> 
    <p>This technique can expand most polymorphic type aliases appearing in Scala codebases but not all of them. For instance, the following alias cannot be expanded, because the parameter type <code>T</code> is not a type member of the right-hand side <code>List[List[T]]</code>.</p> 
    <pre><code class="language-scala">type List2[T] = List[List[T]]
</code></pre> 
    <p>We scanned the Scala standard library for occurrences of polymorphic type aliases and determined that only two occurrences could not be expanded. In <code>io/Codec.scala</code>:</p> 
    <pre><code class="language-scala">type Configure[T] = (T =&gt; T, Boolean)
</code></pre> 
    <p>And in <code>collection/immutable/HashMap.scala</code>:</p> 
    <pre><code class="language-scala">private type MergeFunction[A1, B1] = ((A1, B1), (A1, B1)) =&gt; (A1, B1)
</code></pre> 
    <p>For these cases, we use a fall-back scheme that models a parameterized alias as a <code>Lambda</code> type.</p> 
    <h2><a href="#modelling-polymorphic-type-aliases-general-case" id="modelling-polymorphic-type-aliases-general-case" class="anchor"></a>Modelling polymorphic type aliases: general case</h2> 
    <p>A polymorphic type alias such as:</p> 
    <pre><code class="language-scala">type List2D[T] = List[List[T]]
</code></pre> 
    <p>is represented as a monomorphic type alias of a type lambda. Here's the expanded version of the definition above:</p> 
    <pre><code class="language-scala">type List2D = Lambda$I { type Apply = List[List[$hkArg$0]] }
</code></pre> 
    <p>Here, <code>Lambda$I</code> is a standard trait defined as follows:</p> 
    <pre><code class="language-scala">trait Lambda$I[type $hkArg$0] { type +Apply }
</code></pre> 
    <p>The <code>I</code> suffix of the <code>Lambda</code> trait indicates that it has one invariant type parameter (named $hkArg$0). Other suffixes are <code>P</code> for covariant type parameters, and <code>N</code> for contravariant type parameters. Lambda traits can have more than one type parameter. For instance, here is a trait with contravariant and covariant type parameters:</p> 
    <pre><code class="language-scala">trait Lambda$NP[type -$hkArg$0, +$hkArg$1] { type +Apply } extends Lambda$IP with Lambda$NI
</code></pre> 
    <p>Aside: the <code>+</code> prefix in front of <code>Apply</code> indicates that <code>Apply</code> is a covariant type field. Dotty admits variance annotations on type members.</p> 
    <p>The definition of <code>Lambda$NP</code> shows that <code>Lambda</code> traits form a subtyping hierarchy: Traits which have covariant or contravariant type parameters are subtypes of traits which don't. The supertraits of <code>Lambda$NP</code> would themselves be written as follows.</p> 
    <pre><code class="language-scala">trait Lambda$IP[type $hkArg$0, +$hkArg$1] { type +Apply } extends Lambda$II
trait Lambda$NI[type -$hkArg$0, $hkArg$1] { type +Apply } extends Lambda$II
trait Lambda$II[type $hkArg$0, $hkArg$1] { type +Apply }
</code></pre> 
    <p><code>Lambda</code> traits are special in that they influence how type applications are expanded: If the standard type application <code>T[X1, ..., Xn]</code> leads to a subtype <code>S</code> of a type instance</p> 
    <pre><code class="language-scala">LambdaXYZ { type Arg1 = T1; ...; type ArgN = Tn; type Apply ... }
</code></pre> 
    <p>where all argument fields <code>Arg1, ..., ArgN</code> are concretely defined and the definition of the <code>Apply</code> field may be either abstract or concrete, then the application is further expanded to <code>S # Apply</code>.</p> 
    <p>For instance, the type instance <code>List2D[String]</code> would be expanded to</p> 
    <pre><code class="language-scala">Lambda$I { type $hkArg$0 = String; type Apply = List[List[String]] } # Apply
</code></pre> 
    <p>which in turn simplifies to <code>List[List[String]]</code>.</p> 
    <p>2nd Example: Consider the two aliases</p> 
    <pre><code class="language-scala">type RMap[K, V] = Map[V, K]
type RRMap[K, V] = RMap[V, K]
</code></pre> 
    <p>These expand as follows:</p> 
    <pre><code class="language-scala">type RMap  = Lambda$II { self1 =&gt; type Apply = Map[self1.$hkArg$1, self1.$hkArg$0] }
type RRMap = Lambda$II { self2 =&gt; type Apply = RMap[self2.$hkArg$1, self2.$hkArg$0] }
</code></pre> 
    <p>Substituting the definition of <code>RMap</code> and expanding the type application gives:</p> 
    <pre><code class="language-scala">type RRMap = Lambda$II { self2 =&gt; type Apply =
               Lambda$II { self1 =&gt; type Apply = Map[self1.$hkArg$1, self1.$hkArg$0] }
                 { type $hkArg$0 = self2.$hkArg$1; type $hkArg$1 = self2.$hkArg$0 } # Apply }
</code></pre> 
    <p>Substituting the definitions for <code>self1.$hkArg${1,2}</code> gives:</p> 
    <pre><code class="language-scala">type RRMap = Lambda$II { self2 =&gt; type Apply =
               Lambda$II { self1 =&gt; type Apply = Map[self2.$hkArg$0, self2.$hkArg$1] }
                  { type $hkArg$0 = self2.$hkArg$1; type $hkArg$1 = self2.$hkArg$0 } # Apply }
</code></pre> 
    <p>Simplifiying the <code># Apply</code> selection gives:</p> 
    <pre><code class="language-scala">type RRMap = Lambda$II { self2 =&gt; type Apply = Map[self2.$hkArg$0, self2.$hkArg$1] }
</code></pre> 
    <p>This can be regarded as the eta-expanded version of <code>Map</code>. It has the same expansion as</p> 
    <pre><code class="language-scala">type IMap[K, V] = Map[K, V]
</code></pre> 
    <h2><a href="#modelling-higher-kinded-types" id="modelling-higher-kinded-types" class="anchor"></a>Modelling higher-kinded types</h2> 
    <p>The encoding of higher-kinded types uses again the <code>Lambda</code> traits to represent type constructors. Consider the higher-kinded type declaration</p> 
    <pre><code class="language-scala">type Rep[T]
</code></pre> 
    <p>We expand this to</p> 
    <pre><code class="language-scala">type Rep &lt;: Lambda$I
</code></pre> 
    <p>The type parameters of <code>Rep</code> are the type parameters of its upper bound, so <code>Rep</code> is a unary type constructor.</p> 
    <p>More generally, a higher-kinded type declaration</p> 
    <pre><code class="language-scala">type T[v1 X1 &gt;: S1 &lt;: U1, ..., vn XN &gt;: SN &lt;: UN] &gt;: SR &lt;: UR
</code></pre> 
    <p>is encoded as</p> 
    <pre><code class="language-scala">type T &lt;: LambdaV1...Vn { self =&gt;
  type v1 $hkArg$0 &gt;: s(S1) &lt;: s(U1)
  ...
  type vn $hkArg$N &gt;: s(SN) &lt;: s(UN)
  type Apply &gt;: s(SR) &lt;: s(UR)
}
</code></pre> 
    <p>where <code>s</code> is the substitution <code>[XI := self.$hkArg$I | I = 1,...,N]</code>.</p> 
    <p>If we instantiate <code>Rep</code> with a type argument, this is expanded as was explained before.</p> 
    <pre><code class="language-scala">Rep[String]
</code></pre> 
    <p>would expand to</p> 
    <pre><code class="language-scala">Rep { type $hkArg$0 = String } # Apply
</code></pre> 
    <p>If we instantiate the higher-kinded type with a concrete type constructor (i.e. a parameterized trait or class), we have to do one extra adaptation to make it work. The parameterized trait or class has to be eta-expanded so that it comforms to the <code>Lambda</code> bound. For instance,</p> 
    <pre><code class="language-scala">type Rep = Set
</code></pre> 
    <p>would expand to:</p> 
    <pre><code class="language-scala">type Rep = Lambda1 { type Apply = Set[$hkArg$0] }
</code></pre> 
    <p>Or,</p> 
    <pre><code class="language-scala">type Rep = Map[String, _]
</code></pre> 
    <p>would expand to</p> 
    <pre><code class="language-scala">type Rep = Lambda1 { type Apply = Map[String, $hkArg$0] }
</code></pre> 
    <h2><a href="#full-example" id="full-example" class="anchor"></a>Full example</h2> 
    <p>Consider the higher-kinded <code>Functor</code> type class</p> 
    <pre><code class="language-scala">class Functor[F[_]] {
   def map[A, B](f: A =&gt; B): F[A] =&gt; F[B]
}
</code></pre> 
    <p>This would be represented as follows:</p> 
    <pre><code class="language-scala">class Functor[F &lt;: Lambda1] {
   def map[A, B](f: A =&gt; B): F { type $hkArg$0 = A } # Apply  =&gt;  F { type $hkArg$0 = B } # Apply
}
</code></pre> 
    <p>The type <code>Functor[List]</code> would be represented as follows</p> 
    <pre><code class="language-scala">Functor {
   type F = Lambda1 { type Apply = List[$hkArg$0] }
}
</code></pre> 
    <p>Now, assume we have a value</p> 
    <pre><code class="language-scala">val ml: Functor[List]
</code></pre> 
    <p>Then <code>ml.map</code> would have type</p> 
    <pre><code class="language-scala">s(F { type $hkArg$0 = A } # Apply  =&gt;  F { type $hkArg$0 = B } # Apply)
</code></pre> 
    <p>where <code>s</code> is the substitution of <code>[F := Lambda1 { type Apply = List[$hkArg$0] }]</code>. This gives:</p> 
    <pre><code class="language-scala">Lambda1 { type Apply = List[$hkArg$0] } { type $hkArg$0 = A } # Apply
 =&gt;  Lambda1 { type Apply = List[$hkArg$0] } { type $hkArg$0 = B } # Apply
</code></pre> 
    <p>This type simplifies to:</p> 
    <pre><code class="language-scala">List[A] =&gt; List[B]
</code></pre> 
    <h2><a href="#status-of-" id="status-of-" class="anchor"></a>Status of <code>#</code></h2> 
    <p>In the scheme above we have silently assumed that <code>#</code> "does the right thing", i.e. that the types are well-formed and we can collapse a type alias with a <code>#</code> projection, thereby giving us a form of beta reduction.</p> 
    <p>In Scala 2.x, this would not work, because <code>T#X</code> means <code>x.X forSome { val x: T }</code>. Hence, two occurrences of <code>Rep[Int]</code> say, would not be recognized to be equal because the existential would be opened each time afresh.</p> 
    <p>In pre-existentials Scala, this would not have worked either. There, <code>T#X</code> was a fundamental type constructor, but was restricted to alias types or classes for both <code>T</code> and <code>X</code>. Roughly, <code>#</code> was meant to encode Java's inner classes. In Java, given the classes</p> 
    <pre><code class="language-scala">class Outer { class Inner }
class Sub1 extends Outer
class Sub2 extends Outer
</code></pre> 
    <p>The types <code>Outer#Inner</code>, <code>Sub1#Inner</code> and <code>Sub2#Inner</code> would all exist and be regarded as equal to each other. But if <code>Outer</code> had abstract type members this would not work, since an abstract type member could be instantiated differently in <code>Sub1</code> and <code>Sub2</code>. Assuming that <code>Sub1#Inner = Sub2#Inner</code> could then lead to a soundness hole. To avoid soundness problems, the types in <code>X#Y</code> were restricted so that <code>Y</code> was (an alias of) a class type and <code>X</code> was (an alias of) a class type with no abstract type members.</p> 
    <p>I believe we can go back to regarding <code>T#X</code> as a fundamental type constructor, the way it was done in pre-existential Scala, but with the following relaxed restriction:</p> 
    <blockquote> 
     <p>In a type selection <code>T#x</code>, <code>T</code> is not allowed to have any abstract members different from <code>X</code></p> 
    </blockquote> 
    <p>This would typecheck the higher-kinded types examples, because they only project with <code># Apply</code> once all <code>$hkArg$</code> type members are fully instantiated.</p> 
    <p>It would be good to study this rule formally, trying to verify its soundness.</p> 
   </main> 
  </div> 
  <script>
  ((window.gitter = {}).chat = {}).options = {
    room: 'lampepfl/dotty'
  };
</script> 
  <script src="https://sidecar.gitter.im/dist/sidecar.v1.js" async defer></script>
 </body>
</html>  </div>
</main><footer><span class="go-to-top-icon"><a href="#container"><span class="icon-vertical_align_top"></span>&nbsp;Back to top</a></span>Generated by&nbsp;<a href="https://github.com/lampepfl/dotty/tree/master/scala3doc"><img src="../../images/scala3doc_logo.svg" alt="Scala3doc" class="scala3doc_logo"></img></a></footer></div></div><script type="text/javascript" src="../../scripts/pages.js"></script><script type="text/javascript" src="../../scripts/main.js"></script></body></html>
