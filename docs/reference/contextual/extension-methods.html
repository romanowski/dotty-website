<html><head><meta charset="utf-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><title>Extension Methods</title><link rel="shortcut icon" type="image/x-icon" href="../../../favicon.ico"></link><script type="text/javascript" src="../../../scripts/clipboard.js" defer="true"></script><script type="text/javascript" src="../../../scripts/platform-content-handler.js" defer="true"></script><script type="text/javascript" src="../../../scripts/main.js" defer="true"></script><link rel="stylesheet" href="../../../styles/nord-light.css"></link><link rel="stylesheet" href="../../../styles/scalastyle.css"></link><link rel="stylesheet" href="../../../styles/dotty-icons.css"></link><link rel="stylesheet" href="../../../styles/diagram.css"></link><link rel="stylesheet" href="../../../styles/filter-bar.css"></link><link rel="stylesheet" href="../../../styles/search-bar.css"></link><script type="text/javascript" src="https://code.jquery.com/jquery-3.5.1.min.js" defer="true"></script><script type="text/javascript" src="https://d3js.org/d3.v6.min.js" defer="true"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/graphlib-dot@0.6.2/dist/graphlib-dot.min.js" defer="true"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/dagre-d3/0.6.1/dagre-d3.min.js" defer="true"></script><script type="text/javascript" src="../../../scripts/diagram.js" defer="true"></script><link rel="stylesheet" href="../../../styles/filter-bar.css"></link><script type="text/javascript" src="../../../hljs/highlight.pack.js" defer="true"></script><script type="text/javascript" src="../../../scripts/hljs-scala3.js" defer="true"></script><script type="text/javascript" src="../../../scripts/ux.js" defer="true"></script><script type="text/javascript" src="../../../scripts/common/component.js" defer="true"></script><script type="text/javascript" src="../../../scripts/common/utils.js" defer="true"></script><script type="text/javascript" src="../../../scripts/components/FilterBar.js" defer="true"></script><script type="text/javascript" src="../../../scripts/components/DocumentableList.js" defer="true"></script><script type="text/javascript" src="../../../scripts/components/Input.js" defer="true"></script><script type="text/javascript" src="../../../scripts/components/FilterGroup.js" defer="true"></script><script type="text/javascript" src="../../../scripts/components/Filter.js" defer="true"></script><script type="text/javascript" src="../../../scripts/data.js" defer="true"></script><script type="text/javascript" src="../../../scripts/fast-navigation-loader.js" defer="true"></script><link rel="stylesheet" href="../../../css/bootstrap.min.css"></link><link rel="stylesheet" href="../../../css/dottydoc.css"></link><link rel="stylesheet" href="../../../css/color-brewer.css"></link><script type="text/javascript" src="../../../js/jquery.min.js" defer="true"></script><script type="text/javascript" src="../../../js/bootstrap.min.js" defer="true"></script><script>var pathToRoot = "../../../";</script></head><body><div id="container"><div id="leftColumn"><div id="logo"><span><img src="../../../project-logo/logo.svg"></img></span><span><div class="projectName">Scala 3</div><div class="projectVersion">3.0.0-M2</div></span></div><div id="paneSearch"></div><nav id="sideMenu"></nav></div><div id="main"><div id="leftToggler"><span class="icon-toggler"></span></div><div id="searchBar"></div><main>
  <div id="content" pageIds="_.docs/reference/contextual/extension-methods.md////PointingToDeclaration//-1490135309">
    <div class="breadcrumbs"><a href="../../index.html"></a>/<a href="../../Reference/index.html">Reference</a>/<a href="../../Contextual Abstractions/index.html">Contextual Abstractions</a>/<a href="extension-methods.html">Extension Methods</a></div>
<html>
 <head>
  <link rel="dns-prefetch" href="//fonts.googleapis.com"> 
  <link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin> 
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin> 
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.9.0/css/all.min.css"> 
 </head>
 <body>
  <div id="content-wrapper"> 
   <main class="container"> 
    <header> 
     <h1>"Extension Methods"</h1> 
     <div class="byline"> <a href="https://github.com/lampepfl/dotty/edit/master/docs/docs/reference/contextual/extension-methods.md#L"> <i class="far fa-edit"></i> Edit this page on GitHub </a> 
     </div> 
    </header> 
    <p>Extension methods allow one to add methods to a type after the type is defined. Example:</p> 
    <pre><code class="language-scala">case class Circle(x: Double, y: Double, radius: Double)

extension (c: Circle)
  def circumference: Double = c.radius * math.Pi * 2
</code></pre> 
    <p>Like regular methods, extension methods can be invoked with infix <code>.</code>:</p> 
    <pre><code class="language-scala">val circle = Circle(0, 0, 1)
circle.circumference
</code></pre> 
    <h3><a href="#translation-of-extension-methods" id="translation-of-extension-methods" class="anchor"></a>Translation of Extension Methods</h3> 
    <p>An extension method translates to a specially labelled method that takes the leading parameter section as its first argument list. The label, expressed as <code>&lt;extension&gt;</code> here, is compiler-internal. So, the definition of <code>circumference</code> above translates to the following method, and can also be invoked as such:</p> 
    <pre><code class="language-scala">&lt;extension&gt; def circumference(c: Circle): Double = c.radius * math.Pi * 2

assert(circle.circumference == circumference(circle))
</code></pre> 
    <h3><a href="#operators" id="operators" class="anchor"></a>Operators</h3> 
    <p>The extension method syntax can also be used to define operators. Examples:</p> 
    <pre><code class="language-scala">extension (x: String)
  def &lt; (y: String): Boolean = ...
extension (x: Elem)
  def +: (xs: Seq[Elem]): Seq[Elem] = ...
extension (x: Number)
  @infix def min (y: Number): Number = ...

"ab" &lt; "c"
1 +: List(2, 3)
x min 3
</code></pre> 
    <p>The three definitions above translate to</p> 
    <pre><code class="language-scala">&lt;extension&gt; def &lt; (x: String)(y: String): Boolean = ...
&lt;extension&gt; def +: (xs: Seq[Elem])(x: Elem): Seq[Elem] = ...
@infix &lt;extension&gt; def min(x: Number)(y: Number): Number = ...
</code></pre> 
    <p>Note the swap of the two parameters <code>x</code> and <code>xs</code> when translating the right-associative operator <code>+:</code> to an extension method. This is analogous to the implementation of right binding operators as normal methods. The Scala compiler preprocesses an infix operation <code>x +: xs</code> to <code>xs.+:(x)</code>, so the extension method ends up being applied to the sequence as first argument (in other words, the two swaps cancel each other out).</p> 
    <h3><a href="#generic-extensions" id="generic-extensions" class="anchor"></a>Generic Extensions</h3> 
    <p>It is also possible to extend generic types by adding type parameters to an extension. For instance:</p> 
    <pre><code class="language-scala">extension [T](xs: List[T])
  def second = xs.tail.head

extension [T: Numeric](x: T)
  def + (y: T): T = summon[Numeric[T]].plus(x, y)
</code></pre> 
    <p>If an extension method has type parameters, they come immediately after <code>extension</code> and are followed by the extended parameter. When calling a generic extension method, any explicitly given type arguments follow the method name. So the <code>second</code> method could be instantiated as follows:</p> 
    <pre><code class="language-scala">List(1, 2, 3).second[Int]
</code></pre> 
    <p>Of course, the type argument here would usually be left out since it can be inferred.</p> 
    <p>Extensions can also take using clauses. For instance, the <code>+</code> extension above could equivalently be written with a using clause:</p> 
    <pre><code class="language-scala">extension [T](x: T)(using n: Numeric[T])
  def + (y: T): T = n.plus(x, y)
</code></pre> 
    <p><strong>Note</strong>: Type parameters have to be given after the <code>extension</code> keyword; they cannot be given after the <code>def</code>. This restriction might be lifted in the future once we support multiple type parameter clauses in a method. By contrast, using clauses can be defined for the <code>extension</code> as well as per <code>def</code>.</p> 
    <h3><a href="#collective-extensions" id="collective-extensions" class="anchor"></a>Collective Extensions</h3> 
    <p>Sometimes, one wants to define several extension methods that share the same left-hand parameter type. In this case one can "pull out" the common parameters into a single extension and enclose all methods in braces or an indented region following a '<code>:</code>'. Example:</p> 
    <pre><code class="language-scala">extension (ss: Seq[String]):

  def longestStrings: Seq[String] =
    val maxLength = ss.map(_.length).max
    ss.filter(_.length == maxLength)

  def longestString: String = longestStrings.head
</code></pre> 
    <p>The same can be written with braces as follows (note that indented regions can still be used inside braces):</p> 
    <pre><code class="language-scala">extension (ss: Seq[String]) {

  def longestStrings: Seq[String] =
    val maxLength = ss.map(_.length).max
    ss.filter(_.length == maxLength)

  def longestString: String = longestStrings.head
}
</code></pre> 
    <p>Note the right-hand side of <code>longestString</code>: it calls <code>longestStrings</code> directly, implicitly assuming the common extended value <code>ss</code> as receiver.</p> 
    <p>Collective extensions like these are a shorthand for individual extensions where each method is defined separately. For instance, the first extension above expands to:</p> 
    <pre><code class="language-scala">extension (ss: Seq[String])
  def longestStrings: Seq[String] =
    val maxLength = ss.map(_.length).max
    ss.filter(_.length == maxLength)

extension (ss: Seq[String])
  def longestString: String = ss.longestStrings.head
</code></pre> 
    <p>Collective extensions also can take type parameters and have using clauses. Example:</p> 
    <pre><code class="language-scala">extension [T](xs: List[T])(using Ordering[T]):
  def smallest(n: Int): List[T] = xs.sorted.take(n)
  def smallestIndices(n: Int): List[Int] =
    val limit = smallest(n).max
    xs.zipWithIndex.collect { case (x, i) if x &lt;= limit =&gt; i }
</code></pre> 
    <h3><a href="#translation-of-calls-to-extension-methods" id="translation-of-calls-to-extension-methods" class="anchor"></a>Translation of Calls to Extension Methods</h3> 
    <p>To convert a reference to an extension method, the compiler has to know about the extension method. We say in this case that the extension method is <em>applicable</em> at the point of reference. There are four possible ways for an extension method to be applicable:</p> 
    <ol> 
     <li>The extension method is visible under a simple name, by being defined or inherited or imported in a scope enclosing the reference.</li> 
     <li>The extension method is a member of some given instance that is visible at the point of the reference.</li> 
     <li>The reference is of the form <code>r.m</code> and the extension method is defined in the implicit scope of the type of <code>r</code>.</li> 
     <li>The reference is of the form <code>r.m</code> and the extension method is defined in some given instance in the implicit scope of the type of <code>r</code>.</li> 
    </ol> 
    <p>Here is an example for the first rule:</p> 
    <pre><code class="language-scala">trait IntOps:
  extension (i: Int) def isZero: Boolean = i == 0

  extension (i: Int) def safeMod(x: Int): Option[Int] =
    // extension method defined in same scope IntOps
    if x.isZero then None
    else Some(i % x)

object IntOpsEx extends IntOps:
  extension (i: Int) def safeDiv(x: Int): Option[Int] =
    // extension method brought into scope via inheritance from IntOps
    if x.isZero then None
    else Some(i / x)

trait SafeDiv:
  import IntOpsEx._ // brings safeDiv and safeMod into scope

  extension (i: Int) def divide(d: Int) : Option[(Int, Int)] =
     // extension methods imported and thus in scope
    (i.safeDiv(d), i.safeMod(d)) match
      case (Some(d), Some(r)) =&gt; Some((d, r))
      case _ =&gt; None
</code></pre> 
    <p>By the second rule, an extension method can be made available by defining a given instance containing it, like this:</p> 
    <pre><code class="language-scala">given ops1 as IntOps // brings safeMod into scope

1.safeMod(2)
</code></pre> 
    <p>By the third and fourth rule, an extension method is available if it is in the implicit scope of the receiver type or in a given instance in that scope. Example:</p> 
    <pre><code class="language-scala">class List[T]:
  ...
object List:

  extension [T](xs: List[List[T]])
    def flatten: List[T] = xs.foldLeft(Nil: List[T])(_ ++ _)

  given [T: Ordering] as Ordering[List[T]]:
    extension (xs: List[T])
      def &lt; (ys: List[T]): Boolean = ...
end List

// extension method available since it is in the implicit scope of List[List[Int]]
List(List(1, 2), List(3, 4)).flatten

// extension method available since it is in the given Ordering[List[T]],
// which is itself in the implicit scope of List[Int]
List(1, 2) &lt; List(3)
</code></pre> 
    <p>The precise rules for resolving a selection to an extension method are as follows.</p> 
    <p>Assume a selection <code>e.m[Ts]</code> where <code>m</code> is not a member of <code>e</code>, where the type arguments <code>[Ts]</code> are optional, and where <code>T</code> is the expected type. The following two rewritings are tried in order:</p> 
    <ol> 
     <li>The selection is rewritten to <code>m[Ts](e)</code>.</li> 
     <li> <p>If the first rewriting does not typecheck with expected type <code>T</code>, and there is an extension method <code>m</code> in some eligible object <code>o</code>, the selection is rewritten to <code>o.m[Ts](e)</code>. An object <code>o</code> is <em>eligible</em> if</p> 
      <ul> 
       <li><code>o</code> forms part of the implicit scope of <code>T</code>, or</li> 
       <li><code>o</code> is a given instance that is visible at the point of the application, or</li> 
       <li><code>o</code> is a given instance in the implicit scope of <code>T</code>.</li> 
      </ul> <p>This second rewriting is attempted at the time where the compiler also tries an implicit conversion from <code>T</code> to a type containing <code>m</code>. If there is more than one way of rewriting, an ambiguity error results.</p> </li> 
    </ol> 
    <p>An extension method can also be referenced using a simple identifier without a preceding expression. If an identifier <code>g</code> appears in the body of an extension method <code>f</code> and refers to an extension method <code>g</code> that is defined in the same collective extension</p> 
    <pre><code class="language-scala">extension (x: T)
  def f ... = ... g ...
  def g ...
</code></pre> 
    <p>the identifier is rewritten to <code>x.g</code>. This is also the case if <code>f</code> and <code>g</code> are the same method. Example:</p> 
    <pre><code class="language-scala">extension (s: String)
  def position(ch: Char, n: Int): Int =
    if n &lt; s.length &amp;&amp; s(n) != ch then position(ch, n + 1)
    else n
</code></pre> 
    <p>The recursive call <code>position(ch, n + 1)</code> expands to <code>s.position(ch, n + 1)</code> in this case. The whole extension method rewrites to</p> 
    <pre><code class="language-scala">def position(s: String)(ch: Char, n: Int): Int =
  if n &lt; s.length &amp;&amp; s(n) != ch then position(s)(ch, n + 1)
  else n
</code></pre> 
    <h3><a href="#syntax" id="syntax" class="anchor"></a>Syntax</h3> 
    <p>Here are the syntax changes for extension methods and collective extensions relative to the <a href="../../internals/syntax.md">current syntax</a>.</p> 
    <pre><code>BlockStat         ::=  ... | Extension
TemplateStat      ::=  ... | Extension
TopStat           ::=  ... | Extension
Extension         ::=  ‘extension’ [DefTypeParamClause] ‘(’ DefParam ‘)’
                       {UsingParamClause} ExtMethods
ExtMethods        ::=  ExtMethod | [nl] ‘{’ ExtMethod {semi ExtMethod ‘}’
ExtMethod         ::=  {Annotation [nl]} {Modifier} ‘def’ DefDef
</code></pre> 
    <p><code>extension</code> is a soft keyword. It is recognized as a keyword only if it appears at the start of a statement and is followed by <code>[</code> or <code>(</code>. In all other cases it is treated as an identifier.</p> 
   </main> 
  </div> 
  <script>
  ((window.gitter = {}).chat = {}).options = {
    room: 'lampepfl/dotty'
  };
</script> 
  <script src="https://sidecar.gitter.im/dist/sidecar.v1.js" async defer></script>
 </body>
</html>  </div>
</main><footer><span class="go-to-top-icon"><a href="#container"><span class="icon-vertical_align_top"></span>&nbsp;Back to top</a></span>Generated by&nbsp;<a href="https://github.com/lampepfl/dotty/tree/master/scala3doc"><img src="../../../images/scala3doc_logo.svg" alt="Scala3doc" class="scala3doc_logo"></img></a></footer></div></div><script type="text/javascript" src="../../../scripts/pages.js"></script><script type="text/javascript" src="../../../scripts/main.js"></script></body></html>
