<html><head><meta charset="utf-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><title>Implementing Type classes</title><link rel="shortcut icon" type="image/x-icon" href="../../../favicon.ico"></link><script type="text/javascript" src="../../../scripts/clipboard.js" defer="true"></script><script type="text/javascript" src="../../../scripts/platform-content-handler.js" defer="true"></script><script type="text/javascript" src="../../../scripts/main.js" defer="true"></script><link rel="stylesheet" href="../../../styles/nord-light.css"></link><link rel="stylesheet" href="../../../styles/scalastyle.css"></link><link rel="stylesheet" href="../../../styles/dotty-icons.css"></link><link rel="stylesheet" href="../../../styles/diagram.css"></link><link rel="stylesheet" href="../../../styles/filter-bar.css"></link><link rel="stylesheet" href="../../../styles/search-bar.css"></link><script type="text/javascript" src="https://code.jquery.com/jquery-3.5.1.min.js" defer="true"></script><script type="text/javascript" src="https://d3js.org/d3.v6.min.js" defer="true"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/graphlib-dot@0.6.2/dist/graphlib-dot.min.js" defer="true"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/dagre-d3/0.6.1/dagre-d3.min.js" defer="true"></script><script type="text/javascript" src="../../../scripts/diagram.js" defer="true"></script><link rel="stylesheet" href="../../../styles/filter-bar.css"></link><script type="text/javascript" src="../../../hljs/highlight.pack.js" defer="true"></script><script type="text/javascript" src="../../../scripts/hljs-scala3.js" defer="true"></script><script type="text/javascript" src="../../../scripts/ux.js" defer="true"></script><script type="text/javascript" src="../../../scripts/common/component.js" defer="true"></script><script type="text/javascript" src="../../../scripts/common/utils.js" defer="true"></script><script type="text/javascript" src="../../../scripts/components/FilterBar.js" defer="true"></script><script type="text/javascript" src="../../../scripts/components/DocumentableList.js" defer="true"></script><script type="text/javascript" src="../../../scripts/components/Input.js" defer="true"></script><script type="text/javascript" src="../../../scripts/components/FilterGroup.js" defer="true"></script><script type="text/javascript" src="../../../scripts/components/Filter.js" defer="true"></script><script type="text/javascript" src="../../../scripts/data.js" defer="true"></script><script type="text/javascript" src="../../../scripts/fast-navigation-loader.js" defer="true"></script><link rel="stylesheet" href="../../../css/bootstrap.min.css"></link><link rel="stylesheet" href="../../../css/dottydoc.css"></link><link rel="stylesheet" href="../../../css/color-brewer.css"></link><script type="text/javascript" src="../../../js/jquery.min.js" defer="true"></script><script type="text/javascript" src="../../../js/bootstrap.min.js" defer="true"></script><script>var pathToRoot = "../../../";</script></head><body><div id="container"><div id="leftColumn"><div id="logo"><span><img src="../../../project-logo/logo.svg"></img></span><span><div class="projectName">Scala 3</div><div class="projectVersion">3.0.0-M2</div></span></div><div id="paneSearch"></div><nav id="sideMenu"></nav></div><div id="main"><div id="leftToggler"><span class="icon-toggler"></span></div><div id="searchBar"></div><main>
  <div id="content" pageIds="_.docs/reference/contextual/type-classes.md////PointingToDeclaration//-1490135309">
    <div class="breadcrumbs"><a href="../../index.html"></a>/<a href="../../Reference/index.html">Reference</a>/<a href="../../Contextual Abstractions/index.html">Contextual Abstractions</a>/<a href="type-classes.html">Implementing Type classes</a></div>
<html>
 <head>
  <link rel="dns-prefetch" href="//fonts.googleapis.com"> 
  <link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin> 
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin> 
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.9.0/css/all.min.css"> 
 </head>
 <body>
  <div id="content-wrapper"> 
   <main class="container"> 
    <header> 
     <h1>"Implementing Type classes"</h1> 
     <div class="byline"> <a href="https://github.com/lampepfl/dotty/edit/master/docs/docs/reference/contextual/type-classes.md#L"> <i class="far fa-edit"></i> Edit this page on GitHub </a> 
     </div> 
    </header> 
    <p>A <em>type class</em> is an abstract, parameterized type that lets you add new behavior to any closed data type without using sub-typing. This can be useful in multiple use-cases, for example:</p> 
    <ul> 
     <li>expressing how a type you don't own (from the standard or 3rd-party library) conforms to such behavior</li> 
     <li>expressing such a behavior for multiple types without involving sub-typing relationships (one <code>extends</code> another) between those types (see: <a href="https://en.wikipedia.org/wiki/Ad_hoc_polymorphism">ad hoc polymorphism</a> for instance)</li> 
    </ul> 
    <p>Therefore in Scala 3, <em>type classes</em> are just <em>traits</em> with one or more parameters whose implementations are not defined through the <code>extends</code> keyword, but by <strong>given instances</strong>. Here are some examples of common type classes:</p> 
    <h3><a href="#semigroups-and-monoids" id="semigroups-and-monoids" class="anchor"></a>Semigroups and monoids</h3> 
    <p>Here's the <code>Monoid</code> type class definition:</p> 
    <pre><code class="language-scala">trait SemiGroup[T]:
  extension (x: T) def combine (y: T): T

trait Monoid[T] extends SemiGroup[T]:
  def unit: T
</code></pre> 
    <p>An implementation of this <code>Monoid</code> type class for the type <code>String</code> can be the following:</p> 
    <pre><code class="language-scala">given Monoid[String]:
  extension (x: String) def combine (y: String): String = x.concat(y)
  def unit: String = ""
</code></pre> 
    <p>Whereas for the type <code>Int</code> one could write the following:</p> 
    <pre><code class="language-scala">given Monoid[Int]:
  extension (x: Int) def combine (y: Int): Int = x + y
  def unit: Int = 0
</code></pre> 
    <p>This monoid can now be used as <em>context bound</em> in the following <code>combineAll</code> method:</p> 
    <pre><code class="language-scala">def combineAll[T: Monoid](xs: List[T]): T =
    xs.foldLeft(summon[Monoid[T]].unit)(_.combine(_))
</code></pre> 
    <p>To get rid of the <code>summon[...]</code> we can define a <code>Monoid</code> object as follows:</p> 
    <pre><code class="language-scala">object Monoid:
  def apply[T](using m: Monoid[T]) = m
</code></pre> 
    <p>Which would allow to re-write the <code>combineAll</code> method this way:</p> 
    <pre><code class="language-scala">def combineAll[T: Monoid](xs: List[T]): T =
  xs.foldLeft(Monoid[T].unit)(_.combine(_))
</code></pre> 
    <h3><a href="#functors" id="functors" class="anchor"></a>Functors</h3> 
    <p>A <code>Functor</code> for a type provides the ability for its values to be "mapped over", i.e. apply a function that transforms inside a value while remembering its shape. For example, to modify every element of a collection without dropping or adding elements. We can represent all types that can be "mapped over" with <code>F</code>. It's a type constructor: the type of its values becomes concrete when provided a type argument. Therefore we write it <code>F[_]</code>, hinting that the type <code>F</code> takes another type as argument. The definition of a generic <code>Functor</code> would thus be written as:</p> 
    <pre><code class="language-scala">trait Functor[F[_]]:
  def map[A, B](x: F[A], f: A =&gt; B): F[B]
</code></pre> 
    <p>Which could read as follows: "A <code>Functor</code> for the type constructor <code>F[_]</code> represents the ability to transform <code>F[A]</code> to <code>F[B]</code> through the application of function <code>f</code> with type <code>A =&gt; B</code>". We call the <code>Functor</code> definition here a <em>type class</em>. This way, we could define an instance of <code>Functor</code> for the <code>List</code> type:</p> 
    <pre><code class="language-scala">given Functor[List]:
  def map[A, B](x: List[A], f: A =&gt; B): List[B] =
    x.map(f) // List already has a `map` method
</code></pre> 
    <p>With this <code>given</code> instance in scope, everywhere a <code>Functor</code> is expected, the compiler will accept a <code>List</code> to be used.</p> 
    <p>For instance, we may write such a testing method:</p> 
    <pre><code class="language-scala">def assertTransformation[F[_]: Functor, A, B](expected: F[B], original: F[A], mapping: A =&gt; B): Unit =
  assert(expected == summon[Functor[F]].map(original, mapping))
</code></pre> 
    <p>And use it this way, for example:</p> 
    <pre><code class="language-scala">assertTransformation(List("a1", "b1"), List("a", "b"), elt =&gt; s"${elt}1")
</code></pre> 
    <p>That's a first step, but in practice we probably would like the <code>map</code> function to be a method directly accessible on the type <code>F</code>. So that we can call <code>map</code> directly on instances of <code>F</code>, and get rid of the <code>summon[Functor[F]]</code> part. As in the previous example of Monoids, <a href="extension-methods.html"><code>extension</code> methods</a> help achieving that. Let's re-define the <code>Functor</code> type class with extension methods.</p> 
    <pre><code class="language-scala">trait Functor[F[_]]:
  extension [A, B](x: F[A])
    def map(f: A =&gt; B): F[B]
</code></pre> 
    <p>The instance of <code>Functor</code> for <code>List</code> now becomes:</p> 
    <pre><code class="language-scala">given Functor[List]:
  extension [A, B](xs: List[A])
    def map(f: A =&gt; B): List[B] =
      xs.map(f) // List already has a `map` method

</code></pre> 
    <p>It simplifies the <code>assertTransformation</code> method:</p> 
    <pre><code class="language-scala">def assertTransformation[F[_]: Functor, A, B](expected: F[B], original: F[A], mapping: A =&gt; B): Unit =
  assert(expected == original.map(mapping))
</code></pre> 
    <p>The <code>map</code> method is now directly used on <code>original</code>. It is available as an extension method since <code>original</code>'s type is <code>F[A]</code> and a given instance for <code>Functor[F[A]]</code> which defines <code>map</code> is in scope.</p> 
    <h3><a href="#monads" id="monads" class="anchor"></a>Monads</h3> 
    <p>Applying <code>map</code> in <code>Functor[List]</code> to a mapping function of type <code>A =&gt; B</code> results in a <code>List[B]</code>. So applying it to a mapping function of type <code>A =&gt; List[B]</code> results in a <code>List[List[B]]</code>. To avoid managing lists of lists, we may want to "flatten" the values in a single list.</p> 
    <p>That's where <code>Monad</code> comes in. A <code>Monad</code> for type <code>F[_]</code> is a <code>Functor[F]</code> with two more operations:</p> 
    <ul> 
     <li><code>flatMap</code>, which turns an <code>F[A]</code> into an <code>F[B]</code> when given a function of type <code>A =&gt; F[B]</code>,</li> 
     <li><code>pure</code>, which creates an <code>F[A]</code> from a single value <code>A</code>.</li> 
    </ul> 
    <p>Here is the translation of this definition in Scala 3:</p> 
    <pre><code class="language-scala">trait Monad[F[_]] extends Functor[F]:

  /** The unit value for a monad */
  def pure[A](x: A): F[A]

  extension [A, B](x: F[A])
    /** The fundamental composition operation */
    def flatMap(f: A =&gt; F[B]): F[B]

    /** The `map` operation can now be defined in terms of `flatMap` */
    def map(f: A =&gt; B) = x.flatMap(f.andThen(pure))

end Monad
</code></pre> 
    <h4><a href="#list" id="list" class="anchor"></a>List</h4> 
    <p>A <code>List</code> can be turned into a monad via this <code>given</code> instance:</p> 
    <pre><code class="language-scala">given listMonad as Monad[List]:
  def pure[A](x: A): List[A] =
    List(x)
  extension [A, B](xs: List[A])
    def flatMap(f: A =&gt; List[B]): List[B] =
      xs.flatMap(f) // rely on the existing `flatMap` method of `List`
</code></pre> 
    <p>Since <code>Monad</code> is a subtype of <code>Functor</code>, <code>List</code> is also a functor. The Functor's <code>map</code> operation is already provided by the <code>Monad</code> trait, so the instance does not need to define it explicitly.</p> 
    <h4><a href="#option" id="option" class="anchor"></a>Option</h4> 
    <p><code>Option</code> is an other type having the same kind of behaviour:</p> 
    <pre><code class="language-scala">given optionMonad as Monad[Option]:
  def pure[A](x: A): Option[A] =
    Option(x)
  extension [A, B](xo: Option[A])
    def flatMap(f: A =&gt; Option[B]): Option[B] = xo match
      case Some(x) =&gt; f(x)
      case None =&gt; None
</code></pre> 
    <h4><a href="#reader" id="reader" class="anchor"></a>Reader</h4> 
    <p>Another example of a <code>Monad</code> is the <em>Reader</em> Monad, which acts on functions instead of data types like <code>List</code> or <code>Option</code>. It can be used to combine multiple functions that all need the same parameter. For instance multiple functions needing access to some configuration, context, environment variables, etc.</p> 
    <p>Let's define a <code>Config</code> type, and two functions using it:</p> 
    <pre><code class="language-scala">trait Config
// ...
def compute(i: Int)(config: Config): String = ???
def show(str: String)(config: Config): Unit = ???
</code></pre> 
    <p>We may want to combine <code>compute</code> and <code>show</code> into a single function, accepting a <code>Config</code> as parameter, and showing the result of the computation, and we'd like to use a monad to avoid passing the parameter explicitly multiple times. So postulating the right <code>flatMap</code> operation, we could write:</p> 
    <pre><code class="language-scala">def computeAndShow(i: Int): Config =&gt; Unit = compute(i).flatMap(show)
</code></pre> 
    <p>instead of</p> 
    <pre><code class="language-scala">show(compute(i)(config))(config)
</code></pre> 
    <p>Let's define this m then. First, we are going to define a type named <code>ConfigDependent</code> representing a function that when passed a <code>Config</code> produces a <code>Result</code>.</p> 
    <pre><code class="language-scala">type ConfigDependent[Result] = Config =&gt; Result
</code></pre> 
    <p>The monad instance will look like this:</p> 
    <pre><code class="language-scala">given configDependentMonad as Monad[ConfigDependent]:

  def pure[A](x: A): ConfigDependent[A] =
    config =&gt; x

  extension [A, B](x: ConfigDependent[A])
    def flatMap(f: A =&gt; ConfigDependent[B]): ConfigDependent[B] =
      config =&gt; f(x(config))(config)

end configDependentMonad
</code></pre> 
    <p>The type <code>ConfigDependent</code> can be written using <a href="../new-types/type-lambdas.html">type lambdas</a>:</p> 
    <pre><code class="language-scala">type ConfigDependent = [Result] =&gt;&gt; Config =&gt; Result
</code></pre> 
    <p>Using this syntax would turn the previous <code>configDependentMonad</code> into:</p> 
    <pre><code class="language-scala">given configDependentMonad as Monad[[Result] =&gt;&gt; Config =&gt; Result]

  def pure[A](x: A): Config =&gt; A =
    config =&gt; x

  extension [A, B](x: Config =&gt; A)
    def flatMap(f: A =&gt; Config =&gt; B): Config =&gt; B =
      config =&gt; f(x(config))(config)

end configDependentMonad
</code></pre> 
    <p>It is likely that we would like to use this pattern with other kinds of environments than our <code>Config</code> trait. The Reader monad allows us to abstract away <code>Config</code> as a type <em>parameter</em>, named <code>Ctx</code> in the following definition:</p> 
    <pre><code class="language-scala">given readerMonad[Ctx] as Monad[[X] =&gt;&gt; Ctx =&gt; X]:

  def pure[A](x: A): Ctx =&gt; A =
    ctx =&gt; x

  extension [A, B](x: Ctx =&gt; A)
    def flatMap(f: A =&gt; Ctx =&gt; B): Ctx =&gt; B =
      ctx =&gt; f(x(ctx))(ctx)

end readerMonad
</code></pre> 
    <h3><a href="#summary" id="summary" class="anchor"></a>Summary</h3> 
    <p>The definition of a <em>type class</em> is expressed with a parameterised type with abstract members, such as a <code>trait</code>. The main difference between subtype polymorphism and ad-hoc polymorphism with <em>type classes</em> is how the definition of the <em>type class</em> is implemented, in relation to the type it acts upon. In the case of a <em>type class</em>, its implementation for a concrete type is expressed through a <code>given</code> instance definition, which is supplied as an implicit argument alongside the value it acts upon. With subtype polymorphism, the implementation is mixed into the parents of a class, and only a single term is required to perform a polymorphic operation. The type class solution takes more effort to set up, but is more extensible: Adding a new interface to a class requires changing the source code of that class. But contrast, instances for type classes can be defined anywhere.</p> 
    <p>To conclude, we have seen that traits and given instances, combined with other constructs like extension methods, context bounds and type lambdas allow a concise and natural expression of <em>type classes</em>.</p> 
   </main> 
  </div> 
  <script>
  ((window.gitter = {}).chat = {}).options = {
    room: 'lampepfl/dotty'
  };
</script> 
  <script src="https://sidecar.gitter.im/dist/sidecar.v1.js" async defer></script>
 </body>
</html>  </div>
</main><footer><span class="go-to-top-icon"><a href="#container"><span class="icon-vertical_align_top"></span>&nbsp;Back to top</a></span>Generated by&nbsp;<a href="https://github.com/lampepfl/dotty/tree/master/scala3doc"><img src="../../../images/scala3doc_logo.svg" alt="Scala3doc" class="scala3doc_logo"></img></a></footer></div></div><script type="text/javascript" src="../../../scripts/pages.js"></script><script type="text/javascript" src="../../../scripts/main.js"></script></body></html>
