<html><head><meta charset="utf-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><title>Numeric Literals</title><link rel="shortcut icon" type="image/x-icon" href="../../../favicon.ico"></link><script type="text/javascript" src="../../../scripts/clipboard.js" defer="true"></script><script type="text/javascript" src="../../../scripts/platform-content-handler.js" defer="true"></script><script type="text/javascript" src="../../../scripts/main.js" defer="true"></script><link rel="stylesheet" href="../../../styles/nord-light.css"></link><link rel="stylesheet" href="../../../styles/scalastyle.css"></link><link rel="stylesheet" href="../../../styles/dotty-icons.css"></link><link rel="stylesheet" href="../../../styles/diagram.css"></link><link rel="stylesheet" href="../../../styles/filter-bar.css"></link><link rel="stylesheet" href="../../../styles/search-bar.css"></link><script type="text/javascript" src="https://code.jquery.com/jquery-3.5.1.min.js" defer="true"></script><script type="text/javascript" src="https://d3js.org/d3.v6.min.js" defer="true"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/graphlib-dot@0.6.2/dist/graphlib-dot.min.js" defer="true"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/dagre-d3/0.6.1/dagre-d3.min.js" defer="true"></script><script type="text/javascript" src="../../../scripts/diagram.js" defer="true"></script><link rel="stylesheet" href="../../../styles/filter-bar.css"></link><script type="text/javascript" src="../../../hljs/highlight.pack.js" defer="true"></script><script type="text/javascript" src="../../../scripts/hljs-scala3.js" defer="true"></script><script type="text/javascript" src="../../../scripts/ux.js" defer="true"></script><script type="text/javascript" src="../../../scripts/common/component.js" defer="true"></script><script type="text/javascript" src="../../../scripts/common/utils.js" defer="true"></script><script type="text/javascript" src="../../../scripts/components/FilterBar.js" defer="true"></script><script type="text/javascript" src="../../../scripts/components/DocumentableList.js" defer="true"></script><script type="text/javascript" src="../../../scripts/components/Input.js" defer="true"></script><script type="text/javascript" src="../../../scripts/components/FilterGroup.js" defer="true"></script><script type="text/javascript" src="../../../scripts/components/Filter.js" defer="true"></script><script type="text/javascript" src="../../../scripts/data.js" defer="true"></script><script type="text/javascript" src="../../../scripts/fast-navigation-loader.js" defer="true"></script><link rel="stylesheet" href="../../../css/bootstrap.min.css"></link><link rel="stylesheet" href="../../../css/dottydoc.css"></link><link rel="stylesheet" href="../../../css/color-brewer.css"></link><script type="text/javascript" src="../../../js/jquery.min.js" defer="true"></script><script type="text/javascript" src="../../../js/bootstrap.min.js" defer="true"></script><script>var pathToRoot = "../../../";</script></head><body><div id="container"><div id="leftColumn"><div id="logo"><span><img src="../../../project-logo/logo.svg"></img></span><span><div class="projectName">Scala 3</div><div class="projectVersion">3.0.0-M2</div></span></div><div id="paneSearch"></div><nav id="sideMenu"></nav></div><div id="main"><div id="leftToggler"><span class="icon-toggler"></span></div><div id="searchBar"></div><main>
  <div id="content" pageIds="_.docs/reference/changed-features/numeric-literals.md////PointingToDeclaration//-1490135309">
    <div class="breadcrumbs"><a href="../../index.html"></a>/<a href="../../Reference/index.html">Reference</a>/<a href="../../Other Changed Features/index.html">Other Changed Features</a>/<a href="numeric-literals.html">Numeric Literals</a></div>
<html>
 <head>
  <link rel="dns-prefetch" href="//fonts.googleapis.com"> 
  <link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin> 
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin> 
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.9.0/css/all.min.css"> 
 </head>
 <body>
  <div id="content-wrapper"> 
   <main class="container"> 
    <header> 
     <h1>Numeric Literals</h1> 
     <div class="byline"> <a href="https://github.com/lampepfl/dotty/edit/master/docs/docs/reference/changed-features/numeric-literals.md#L"> <i class="far fa-edit"></i> Edit this page on GitHub </a> 
     </div> 
    </header> 
    <p><strong>Note</strong>: This feature is not yet part of the Scala 3 language definition. It can be made available by a language import:</p> 
    <pre><code class="language-scala">import scala.language.experimental.genericNumberLiterals
</code></pre> 
    <p>In Scala 2, numeric literals were confined to the primitive numeric types <code>Int</code>, <code>Long</code>, <code>Float</code>, and <code>Double</code>. Scala 3 allows to write numeric literals also for user defined types. Example:</p> 
    <pre><code class="language-scala">val x: Long = -10_000_000_000
val y: BigInt = 0x123_abc_789_def_345_678_901
val z: BigDecimal = 110_222_799_799.99

(y: BigInt) match {
  case 123_456_789_012_345_678_901 =&gt;
}
</code></pre> 
    <p>The syntax of numeric literals is the same as before, except there are no pre-set limits how large they can be.</p> 
    <h3><a href="#meaning-of-numeric-literals" id="meaning-of-numeric-literals" class="anchor"></a>Meaning of Numeric Literals</h3> 
    <p>The meaning of a numeric literal is determined as follows:</p> 
    <ul> 
     <li>If the literal ends with <code>l</code> or <code>L</code>, it is a <code>Long</code> integer (and must fit in its legal range).</li> 
     <li>If the literal ends with <code>f</code> or <code>F</code>, it is a single precision floating point number of type <code>Float</code>.</li> 
     <li>If the literal ends with <code>d</code> or <code>D</code>, it is a double precision floating point number of type <code>Double</code>.</li> 
    </ul> 
    <p>In each of these cases the conversion to a number is exactly as in Scala 2 or in Java. If a numeric literal does <em>not</em> end in one of these suffixes, its meaning is determined by the expected type:</p> 
    <ol> 
     <li>If the expected type is <code>Int</code>, <code>Long</code>, <code>Float</code>, or <code>Double</code>, the literal is treated as a standard literal of that type.</li> 
     <li>If the expected type is a fully defined type <code>T</code> that has a given instance of type <code>scala.util.FromDigits[T]</code>, the literal is converted to a value of type <code>T</code> by passing it as an argument to the <code>fromDigits</code> method of that instance (more details below).</li> 
     <li>Otherwise, the literal is treated as a <code>Double</code> literal (if it has a decimal point or an exponent), or as an <code>Int</code> literal (if not). (This last possibility is again as in Scala 2 or Java.)</li> 
    </ol> 
    <p>With these rules, the definition</p> 
    <pre><code class="language-scala">val x: Long = -10_000_000_000
</code></pre> 
    <p>is legal by rule (1), since the expected type is <code>Long</code>. The definitions</p> 
    <pre><code class="language-scala">val y: BigInt = 0x123_abc_789_def_345_678_901
val z: BigDecimal = 111222333444.55
</code></pre> 
    <p>are legal by rule (2), since both <code>BigInt</code> and <code>BigDecimal</code> have <code>FromDigits</code> instances (which implement the <code>FromDigits</code> subclasses <code>FromDigits.WithRadix</code> and <code>FromDigits.Decimal</code>, respectively). On the other hand,</p> 
    <pre><code class="language-scala">val x = -10_000_000_000
</code></pre> 
    <p>gives a type error, since without an expected type <code>-10_000_000_000</code> is treated by rule (3) as an <code>Int</code> literal, but it is too large for that type.</p> 
    <h3><a href="#the-fromdigits-trait" id="the-fromdigits-trait" class="anchor"></a>The FromDigits Trait</h3> 
    <p>To allow numeric literals, a type simply has to define a <code>given</code> instance of the <code>scala.util.FromDigits</code> type class, or one of its subclasses. <code>FromDigits</code> is defined as follows:</p> 
    <pre><code class="language-scala">trait FromDigits[T] {
  def fromDigits(digits: String): T
}
</code></pre> 
    <p>Implementations of the <code>fromDigits</code> convert strings of digits to the values of the implementation type <code>T</code>. The <code>digits</code> string consists of digits between <code>0</code> and <code>9</code>, possibly preceded by a sign ("+" or "-"). Number separator characters <code>_</code> are filtered out before the string is passed to <code>fromDigits</code>.</p> 
    <p>The companion object <code>FromDigits</code> also defines subclasses of <code>FromDigits</code> for whole numbers with a given radix, for numbers with a decimal point, and for numbers that can have both a decimal point and an exponent:</p> 
    <pre><code class="language-scala">object FromDigits {

  /** A subclass of `FromDigits` that also allows to convert whole number literals
   *  with a radix other than 10
   */
  trait WithRadix[T] extends FromDigits[T] {
    def fromDigits(digits: String): T = fromDigits(digits, 10)
    def fromDigits(digits: String, radix: Int): T
  }

  /** A subclass of `FromDigits` that also allows to convert number
   *  literals containing a decimal point ".".
   */
  trait Decimal[T] extends FromDigits[T]

  /** A subclass of `FromDigits`that allows also to convert number
   *  literals containing a decimal point "." or an
   *  exponent `('e' | 'E')['+' | '-']digit digit*`.
   */
  trait Floating[T] extends Decimal[T]
  ...
}
</code></pre> 
    <p>A user-defined number type can implement one of those, which signals to the compiler that hexadecimal numbers, decimal points, or exponents are also accepted in literals for this type.</p> 
    <h3><a href="#error-handling" id="error-handling" class="anchor"></a>Error Handling</h3> 
    <p><code>FromDigits</code> implementations can signal errors by throwing exceptions of some subtype of <code>FromDigitsException</code>. <code>FromDigitsException</code> is defined with three subclasses in the <code>FromDigits</code> object as follows:</p> 
    <pre><code class="language-scala">abstract class FromDigitsException(msg: String) extends NumberFormatException(msg)

class NumberTooLarge (msg: String = "number too large")         extends FromDigitsException(msg)
class NumberTooSmall (msg: String = "number too small")         extends FromDigitsException(msg)
class MalformedNumber(msg: String = "malformed number literal") extends FromDigitsException(msg)
</code></pre> 
    <h3><a href="#example" id="example" class="anchor"></a>Example</h3> 
    <p>As a fully worked out example, here is an implementation of a new numeric class, <code>BigFloat</code>, that accepts numeric literals. <code>BigFloat</code> is defined in terms of a <code>BigInt</code> mantissa and an <code>Int</code> exponent:</p> 
    <pre><code class="language-scala">case class BigFloat(mantissa: BigInt, exponent: Int) {
  override def toString = s"${mantissa}e${exponent}"
}
</code></pre> 
    <p><code>BigFloat</code> literals can have a decimal point as well as an exponent. E.g. the following expression should produce the <code>BigFloat</code> number <code>BigFloat(-123, 997)</code>:</p> 
    <pre><code class="language-scala">-0.123E+1000: BigFloat
</code></pre> 
    <p>The companion object of <code>BigFloat</code> defines an <code>apply</code> constructor method to construct a <code>BigFloat</code> from a <code>digits</code> string. Here is a possible implementation:</p> 
    <pre><code class="language-scala">object BigFloat {
  import scala.util.FromDigits

  def apply(digits: String): BigFloat = {
    val (mantissaDigits, givenExponent) = digits.toUpperCase.split('E') match {
      case Array(mantissaDigits, edigits) =&gt;
        val expo =
          try FromDigits.intFromDigits(edigits)
          catch {
            case ex: FromDigits.NumberTooLarge =&gt;
              throw FromDigits.NumberTooLarge(s"exponent too large: $edigits")
          }
        (mantissaDigits, expo)
      case Array(mantissaDigits) =&gt;
        (mantissaDigits, 0)
    }
    val (intPart, exponent) = mantissaDigits.split('.') match {
      case Array(intPart, decimalPart) =&gt;
        (intPart ++ decimalPart, givenExponent - decimalPart.length)
      case Array(intPart) =&gt;
        (intPart, givenExponent)
    }
    BigFloat(BigInt(intPart), exponent)
  }
</code></pre> 
    <p>To accept <code>BigFloat</code> literals, all that's needed in addition is a <code>given</code> instance of type <code>FromDigits.Floating[BigFloat]</code>:</p> 
    <pre><code class="language-scala">  given FromDigits as FromDigits.Floating[BigFloat] {
    def fromDigits(digits: String) = apply(digits)
  }
} // end BigFloat
</code></pre> 
    <p>Note that the <code>apply</code> method does not check the format of the <code>digits</code> argument. It is assumed that only valid arguments are passed. For calls coming from the compiler that assumption is valid, since the compiler will first check whether a numeric literal has the correct format before it gets passed on to a conversion method.</p> 
    <h3><a href="#compile-time-errors" id="compile-time-errors" class="anchor"></a>Compile-Time Errors</h3> 
    <p>With the setup of the previous section, a literal like</p> 
    <pre><code class="language-scala">1e10_0000_000_000: BigFloat
</code></pre> 
    <p>would be expanded by the compiler to</p> 
    <pre><code class="language-scala">BigFloat.FromDigits.fromDigits("1e100000000000")
</code></pre> 
    <p>Evaluating this expression throws a <code>NumberTooLarge</code> exception at run time. We would like it to produce a compile-time error instead. We can achieve this by tweaking the <code>BigFloat</code> class with a small dose of metaprogramming. The idea is to turn the <code>fromDigits</code> method into a macro, i.e. make it an inline method with a splice as right hand side. To do this, replace the <code>FromDigits</code> instance in the <code>BigFloat</code> object by the following two definitions:</p> 
    <pre><code class="language-scala">object BigFloat {
  ...

  class FromDigits extends FromDigits.Floating[BigFloat] {
    def fromDigits(digits: String) = apply(digits)
  }

  given FromDigits {
    override inline def fromDigits(digits: String) = ${
      fromDigitsImpl('digits)
    }
  }
</code></pre> 
    <p>Note that an inline method cannot directly fill in for an abstract method, since it produces no code that can be executed at runtime. That is why we define an intermediary class <code>FromDigits</code> that contains a fallback implementation which is then overridden by the inline method in the <code>FromDigits</code> given instance. That method is defined in terms of a macro implementation method <code>fromDigitsImpl</code>. Here is its definition:</p> 
    <pre><code class="language-scala">  private def fromDigitsImpl(digits: Expr[String])(using ctx: Quotes): Expr[BigFloat] =
    digits match {
      case Const(ds) =&gt;
        try {
          val BigFloat(m, e) = apply(ds)
          '{BigFloat(${Expr(m)}, ${Expr(e)})}
        }
        catch {
          case ex: FromDigits.FromDigitsException =&gt;
            ctx.error(ex.getMessage)
            '{BigFloat(0, 0)}
        }
      case digits =&gt;
        '{apply($digits)}
    }
} // end BigFloat
</code></pre> 
    <p>The macro implementation takes an argument of type <code>Expr[String]</code> and yields a result of type <code>Expr[BigFloat]</code>. It tests whether its argument is a constant string. If that is the case, it converts the string using the <code>apply</code> method and lifts the resulting <code>BigFloat</code> back to <code>Expr</code> level. For non-constant strings <code>fromDigitsImpl(digits)</code> is simply <code>apply(digits)</code>, i.e. everything is evaluated at runtime in this case.</p> 
    <p>The interesting part is the <code>catch</code> part of the case where <code>digits</code> is constant. If the <code>apply</code> method throws a <code>FromDigitsException</code>, the exception's message is issued as a compile time error in the <code>ctx.error(ex.getMessage)</code> call.</p> 
    <p>With this new implementation, a definition like</p> 
    <pre><code class="language-scala">val x: BigFloat = 1234.45e3333333333
</code></pre> 
    <p>would give a compile time error message:</p> 
    <pre><code class="language-scala">3 |  val x: BigFloat = 1234.45e3333333333
  |                    ^^^^^^^^^^^^^^^^^^
  |                    exponent too large: 3333333333
</code></pre> 
   </main> 
  </div> 
  <script>
  ((window.gitter = {}).chat = {}).options = {
    room: 'lampepfl/dotty'
  };
</script> 
  <script src="https://sidecar.gitter.im/dist/sidecar.v1.js" async defer></script>
 </body>
</html>  </div>
</main><footer><span class="go-to-top-icon"><a href="#container"><span class="icon-vertical_align_top"></span>&nbsp;Back to top</a></span>Generated by&nbsp;<a href="https://github.com/lampepfl/dotty/tree/master/scala3doc"><img src="../../../images/scala3doc_logo.svg" alt="Scala3doc" class="scala3doc_logo"></img></a></footer></div></div><script type="text/javascript" src="../../../scripts/pages.js"></script><script type="text/javascript" src="../../../scripts/main.js"></script></body></html>
