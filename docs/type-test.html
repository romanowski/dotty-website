<html><head><meta charset="utf-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><title>TypeTest</title><script type="text/javascript" src="../scripts/clipboard.js" defer="true"></script><script type="text/javascript" src="../scripts/platform-content-handler.js" defer="true"></script><script type="text/javascript" src="../scripts/main.js" defer="true"></script><link rel="stylesheet" href="../styles/nord-light.css"></link><link rel="stylesheet" href="../styles/scalastyle.css"></link><link rel="stylesheet" href="../styles/dotty-icons.css"></link><link rel="stylesheet" href="../styles/diagram.css"></link><link rel="stylesheet" href="../styles/filter-bar.css"></link><link rel="stylesheet" href="../styles/search-bar.css"></link><script type="text/javascript" src="https://code.jquery.com/jquery-3.5.1.min.js" defer="true"></script><script type="text/javascript" src="https://d3js.org/d3.v6.min.js" defer="true"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/graphlib-dot@0.6.2/dist/graphlib-dot.min.js" defer="true"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/dagre-d3/0.6.1/dagre-d3.min.js" defer="true"></script><script type="text/javascript" src="../scripts/diagram.js" defer="true"></script><link rel="stylesheet" href="../styles/filter-bar.css"></link><script type="text/javascript" src="../hljs/highlight.pack.js" defer="true"></script><script type="text/javascript" src="../scripts/hljs-scala3.js" defer="true"></script><script type="text/javascript" src="../scripts/ux.js" defer="true"></script><script type="text/javascript" src="../scripts/common/component.js" defer="true"></script><script type="text/javascript" src="../scripts/common/utils.js" defer="true"></script><script type="text/javascript" src="../scripts/components/FilterBar.js" defer="true"></script><script type="text/javascript" src="../scripts/components/DocumentableList.js" defer="true"></script><script type="text/javascript" src="../scripts/components/Input.js" defer="true"></script><script type="text/javascript" src="../scripts/components/FilterGroup.js" defer="true"></script><script type="text/javascript" src="../scripts/components/Filter.js" defer="true"></script><script type="text/javascript" src="../scripts/data.js" defer="true"></script><script type="text/javascript" src="../scripts/fast-navigation-loader.js" defer="true"></script><link rel="stylesheet" href="../css/bootstrap.min.css"></link><link rel="stylesheet" href="../css/dottydoc.css"></link><link rel="stylesheet" href="../css/color-brewer.css"></link><script type="text/javascript" src="../js/jquery.min.js" defer="true"></script><script type="text/javascript" src="../js/bootstrap.min.js" defer="true"></script><script>var pathToRoot = "../";</script></head><body><div id="container"><div id="leftColumn"><div id="logo"></div><div id="paneSearch"></div><nav id="sideMenu"></nav></div><div id="main"><div id="leftToggler"><span class="icon-toggler"></span></div><div id="searchBar"></div><main>
  <div id="content" pageIds="_.docs/reference/other-new-features/type-test.md////PointingToDeclaration//-1025483213">
    <div class="breadcrumbs"><a href="index.html"></a>/<a href="type-test.html">TypeTest</a></div>
<html>
 <head>
  <link rel="dns-prefetch" href="//fonts.googleapis.com"> 
  <link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin> 
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin> 
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.9.0/css/all.min.css"> 
 </head>
 <body>
  <div id="content-wrapper"> 
   <main class="container"> 
    <header> 
     <h1>"TypeTest"</h1> 
     <div class="byline"> <a href="/edit/master//"> <i class="far fa-edit"></i> Edit this page on GitHub </a> 
     </div> 
    </header> 
    <h2>TypeTest</h2> 
    <p>When pattern matching there are two situations where were a runtime type test must be performed. The first is kind is an explicit type test using the ascription pattern notation.</p> 
    <pre><code class="language-scala">(x: X) match
  case y: Y =&gt;
</code></pre> 
    <p>The second is when an extractor takes an argument that is not a subtype of the scrutinee type.</p> 
    <pre><code class="language-scala">(x: X) match
  case y @ Y(n) =&gt;

object Y:
  def unapply(x: Y): Some[Int] = ...
</code></pre> 
    <p>In both cases, a class test will be performed at runtime. But when the type test is on an abstract type (type parameter or type member), the test cannot be performed because the type is erased at runtime.</p> 
    <p>A <code>TypeTest</code> can be provided to make this test possible.</p> 
    <pre><code class="language-scala">package scala.reflect

trait TypeTest[-S, T]:
  def unapply(s: S): Option[s.type &amp; T]
</code></pre> 
    <p>It provides an extractor that returns its argument typed as a <code>T</code> if the argument is a <code>T</code>. It can be used to encode a type test.</p> 
    <pre><code class="language-scala">def f[X, Y](x: X)(using tt: TypeTest[X, Y]): Option[Y] =
  x match
    case tt(x @ Y(1)) =&gt; Some(x)
    case tt(x) =&gt; Some(x)
    case _ =&gt; None
</code></pre> 
    <p>To avoid the syntactic overhead the compiler will look for a type test automatically if it detects that the type test is on abstract types. This means that <code>x: Y</code> is transformed to <code>tt(x)</code> and <code>x @ Y(_)</code> to <code>tt(x @ Y(_))</code> if there is a contextual <code>TypeTest[X, Y]</code> in scope. The previous code is equivalent to</p> 
    <pre><code class="language-scala">def f[X, Y](x: X)(using TypeTest[X, Y]): Option[Y] =
  x match
    case x @ Y(1) =&gt; Some(x)
    case x: Y =&gt; Some(x)
    case _ =&gt; None
</code></pre> 
    <p>We could create a type test at call site where the type test can be performed with runtime class tests directly as follows</p> 
    <pre><code class="language-scala">val tt: TypeTest[Any, String] =
  new TypeTest[Any, String]
    def unapply(s: Any): Option[s.type &amp; String] =
      s match
        case s: String =&gt; Some(s)
        case _ =&gt; None

f[AnyRef, String]("acb")(using tt)
</code></pre> 
    <p>The compiler will synthesize a new instance of a type test if none is found in scope as:</p> 
    <pre><code class="language-scala">new TypeTest[A, B]:
  def unapply(s: A): Option[s.type &amp; B] =
    s match
      case s: B =&gt; Some(s)
      case _ =&gt; None
</code></pre> 
    <p>If the type tests cannot be done there will be an unchecked warning that will be raised on the <code>case s: B =&gt;</code> test.</p> 
    <p>The most common <code>TypeTest</code> instances are the ones that take any parameters (i.e. <code>TypeTest[Any, T]</code>). To make it possible to use such instances directly in context bounds we provide the alias</p> 
    <pre><code class="language-scala">package scala.reflect

type Typeable[T] = TypeTest[Any, T]
</code></pre> 
    <p>This alias can be used as</p> 
    <pre><code class="language-scala">def f[T: Typeable]: Boolean =
  "abc" match
    case x: T =&gt; true
    case _ =&gt; false

f[String] // true
f[Int] // fasle
</code></pre> 
    <h3>TypeTest and ClassTag</h3> 
    <p><code>TypeTest</code> is a replacement for functionality provided previously by <code>ClassTag.unapply</code>. Using <code>ClassTag</code> instances was unsound since classtags can check only the class component of a type. <code>TypeTest</code> fixes that unsoundness. <code>ClassTag</code> type tests are still supported but a warning will be emitted after 3.0.</p> 
    <h2>Examples</h2> 
    <p>Given the following abstract definition of <code>Peano</code> numbers that provides <code>TypeTest[Nat, Zero]</code> and <code>TypeTest[Nat, Succ]</code></p> 
    <pre><code class="language-scala">trait Peano:
  type Nat
  type Zero &lt;: Nat
  type Succ &lt;: Nat
  def safeDiv(m: Nat, n: Succ): (Nat, Nat)
  val Zero: Zero
  val Succ: SuccExtractor
  trait SuccExtractor {
    def apply(nat: Nat): Succ
    def unapply(nat: Succ): Option[Nat]
  }
  given TypeTest[Nat, Zero] = typeTestOfZero
  protected def typeTestOfZero: TypeTest[Nat, Zero]
  given TypeTest[Nat, Succ] = typeTestOfSucc
  protected def typeTestOfSucc: TypeTest[Nat, Succ]
</code></pre> 
    <p>it will be possible to write the following program</p> 
    <pre><code class="language-scala">val peano: Peano = ...
import peano._
def divOpt(m: Nat, n: Nat): Option[(Nat, Nat)] =
  n match
    case Zero =&gt; None
    case s @ Succ(_) =&gt; Some(safeDiv(m, s))

val two = Succ(Succ(Zero))
val five = Succ(Succ(Succ(two)))
println(divOpt(five, two))
</code></pre> 
    <p>Note that without the <code>TypeTest[Nat, Succ]</code> the pattern <code>Succ.unapply(nat: Succ)</code> would be unchecked.</p> 
   </main> 
  </div> 
  <script>
  ((window.gitter = {}).chat = {}).options = {
    room: 'lampepfl/dotty'
  };
</script> 
  <script src="https://sidecar.gitter.im/dist/sidecar.v1.js" async defer></script>
 </body>
</html>  </div>
</main><footer><span class="go-to-top-icon"><a href="#container"><span class="icon-vertical_align_top"></span>&nbsp;Back to top</a></span><span class="pull-right">Generated by&nbsp;<a href="https://github.com/lampepfl/scala3doc">Scala3doc</a></span></footer></div></div><script type="text/javascript" src="../scripts/pages.js"></script><script type="text/javascript" src="../scripts/main.js"></script></body></html>
