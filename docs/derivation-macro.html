<html><head><meta charset="utf-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><title>How to write a type class `derived` method using macros</title><script type="text/javascript" src="../scripts/clipboard.js" defer="true"></script><script type="text/javascript" src="../scripts/platform-content-handler.js" defer="true"></script><script type="text/javascript" src="../scripts/main.js" defer="true"></script><link rel="stylesheet" href="../styles/nord-light.css"></link><link rel="stylesheet" href="../styles/scalastyle.css"></link><link rel="stylesheet" href="../styles/dotty-icons.css"></link><link rel="stylesheet" href="../styles/diagram.css"></link><link rel="stylesheet" href="../styles/filter-bar.css"></link><link rel="stylesheet" href="../styles/search-bar.css"></link><script type="text/javascript" src="https://code.jquery.com/jquery-3.5.1.min.js" defer="true"></script><script type="text/javascript" src="https://d3js.org/d3.v6.min.js" defer="true"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/graphlib-dot@0.6.2/dist/graphlib-dot.min.js" defer="true"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/dagre-d3/0.6.1/dagre-d3.min.js" defer="true"></script><script type="text/javascript" src="../scripts/diagram.js" defer="true"></script><link rel="stylesheet" href="../styles/filter-bar.css"></link><script type="text/javascript" src="../hljs/highlight.pack.js" defer="true"></script><script type="text/javascript" src="../scripts/hljs-scala3.js" defer="true"></script><script type="text/javascript" src="../scripts/ux.js" defer="true"></script><script type="text/javascript" src="../scripts/common/component.js" defer="true"></script><script type="text/javascript" src="../scripts/common/utils.js" defer="true"></script><script type="text/javascript" src="../scripts/components/FilterBar.js" defer="true"></script><script type="text/javascript" src="../scripts/components/DocumentableList.js" defer="true"></script><script type="text/javascript" src="../scripts/components/Input.js" defer="true"></script><script type="text/javascript" src="../scripts/components/FilterGroup.js" defer="true"></script><script type="text/javascript" src="../scripts/components/Filter.js" defer="true"></script><script type="text/javascript" src="../scripts/data.js" defer="true"></script><script type="text/javascript" src="../scripts/fast-navigation-loader.js" defer="true"></script><link rel="stylesheet" href="../css/bootstrap.min.css"></link><link rel="stylesheet" href="../css/dottydoc.css"></link><link rel="stylesheet" href="../css/color-brewer.css"></link><script type="text/javascript" src="../js/jquery.min.js" defer="true"></script><script type="text/javascript" src="../js/bootstrap.min.js" defer="true"></script><script>var pathToRoot = "../";</script></head><body><div id="container"><div id="leftColumn"><div id="logo"></div><div id="paneSearch"></div><nav id="sideMenu"></nav></div><div id="main"><div id="leftToggler"><span class="icon-toggler"></span></div><div id="searchBar"></div><main>
  <div id="content" pageIds="_.docs/reference/contextual/derivation-macro.md////PointingToDeclaration//-1025483213">
    <div class="breadcrumbs"><a href="index.html"></a>/<a href="derivation-macro.html">How to write a type class `derived` method using macros</a></div>
<html>
 <head>
  <link rel="dns-prefetch" href="//fonts.googleapis.com"> 
  <link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin> 
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin> 
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.9.0/css/all.min.css"> 
 </head>
 <body>
  <div id="content-wrapper"> 
   <main class="container"> 
    <header> 
     <h1>How to write a type class `derived` method using macros</h1> 
     <div class="byline"> <a href="/edit/master//"> <i class="far fa-edit"></i> Edit this page on GitHub </a> 
     </div> 
    </header> 
    <p>In the main <a href="./derivation.md">derivation</a> documentation page, we explained the details behind <code>Mirror</code>s and type class derivation. Here we demonstrate how to implement a type class <code>derived</code> method using macros only. We follow the same example of deriving <code>Eq</code> instances and for simplicity we support a <code>Product</code> type e.g., a case class <code>Person</code>. The low-level method we will use to implement the <code>derived</code> method exploits quotes, splices of both expressions and types and the <code>scala.quoted.Expr.summon</code> method which is the equivalent of <code>summonFrom</code>. The former is suitable for use in a quote context, used within macros.</p> 
    <p>As in the original code, the type class definition is the same:</p> 
    <pre><code class="language-scala">trait Eq[T] {
  def eqv(x: T, y: T): Boolean
}
</code></pre> 
    <p>we need to implement a method <code>Eq.derived</code> on the companion object of <code>Eq</code> that produces a quoted instance for <code>Eq[T]</code>. Here is a possible signature,</p> 
    <pre><code class="language-scala">given derived[T: Type](using qctx: QuoteContext) as Expr[Eq[T]]
</code></pre> 
    <p>and for comparison reasons we give the same signature we had with <code>inline</code>:</p> 
    <pre><code class="language-scala">inline given derived[T] as (m: Mirror.Of[T]) =&gt; Eq[T] = ???
</code></pre> 
    <p>Note, that since a type is used in a subsequent stage it will need to be lifted to a <code>Type</code> by using the corresponding context bound. Also, not that we can summon the quoted <code>Mirror</code> inside the body of the <code>derived</code> this we can omit it from the signature. The body of the <code>derived</code> method is shown below:</p> 
    <pre><code class="language-scala">given derived[T: Type](using qctx: QuoteContext) as Expr[Eq[T]] = {
  import qctx.reflect._

  val ev: Expr[Mirror.Of[T]] = Expr.summon(using '[Mirror.Of[T]]).get

  ev match {
    case '{ $m: Mirror.ProductOf[T] { type MirroredElemTypes = $elementTypes }} =&gt;
      val elemInstances = summonAll(elementTypes)
      val eqProductBody: (Expr[T], Expr[T]) =&gt; Expr[Boolean] = (x, y) =&gt; {
        elemInstances.zipWithIndex.foldLeft(Expr(true: Boolean)) {
          case (acc, (elem, index)) =&gt;
            val e1 = '{$x.asInstanceOf[Product].productElement(${Expr(index)})}
            val e2 = '{$y.asInstanceOf[Product].productElement(${Expr(index)})}

            '{ $acc &amp;&amp; $elem.asInstanceOf[Eq[Any]].eqv($e1, $e2) }
        }
      }
      '{
        eqProduct((x: T, y: T) =&gt; ${eqProductBody('x, 'y)})
      }

    // case for Mirror.ProductOf[T]
    // ...
  }
}
</code></pre> 
    <p>Note, that in the <code>inline</code> case we can merely write <code>summonAll[m.MirroredElemTypes]</code> inside the inline method but here, since <code>Expr.summon</code> is required, we can extract the element types in a macro fashion. Being inside a macro, our first reaction would be to write the code below. Since the path inside the type argument is not stable this cannot be used:</p> 
    <pre><code class="language-scala">'{
  summonAll[$m.MirroredElemTypes]
}
</code></pre> 
    <p>Instead we extract the tuple-type for element types using pattern matching over quotes and more specifically of the refined type:</p> 
    <pre><code class="language-scala"> case '{ $m: Mirror.ProductOf[T] { type MirroredElemTypes = $elementTypes } } =&gt; ...
</code></pre> 
    <p>The implementation of <code>summonAll</code> as a macro can be show below assuming that we have the given instances for our primitive types:</p> 
    <pre><code class="language-scala">  def summonAll[T](t: Type[T])(using qctx: QuoteContext): List[Expr[Eq[_]]] = t match {
    case '[String *: $tpes] =&gt; '{ summon[Eq[String]] }  :: summonAll(tpes)
    case '[Int *: $tpes]    =&gt; '{ summon[Eq[Int]] }     :: summonAll(tpes)
    case '[$tpe *: $tpes]   =&gt; derived(using tpe, qctx) :: summonAll(tpes)
    case '[EmptyTuple] =&gt; Nil
  }
</code></pre> 
    <p>One additional difference with the body of <code>derived</code> here as opposed to the one with <code>inline</code> is that with macros we need to synthesize the body of the code during the macro-expansion time. That is the rationale behind the <code>eqProductBody</code> function. Assuming that we calculate the equality of two <code>Person</code>s defined with a case class that holds a name of type <code>String</code> and an age of type <code>Int</code>, the equality check we want to generate is the following:</p> 
    <pre><code class="language-scala">true
  &amp;&amp; Eq[String].eqv(x.productElement(0),y.productElement(0))
  &amp;&amp; Eq[Int].eqv(x.productElement(1), y.productElement(1))
</code></pre> 
    <h3>Calling the derived method inside the macro</h3> 
    <p>Following the rules in <a href="../metaprogramming/toc.md">Macros</a> we create two methods. One that hosts the top-level splice <code>eqv</code> and one that is the implementation. Alternatively and what is shown below is that we can call the <code>eqv</code> method directly. The <code>eqGen</code> can trigger the derivation.</p> 
    <pre><code class="language-scala">extension [T](x: =&gt;T)
  inline def === (y: =&gt;T)(using eq: Eq[T]): Boolean = eq.eqv(x, y)

implicit inline def eqGen[T]: Eq[T] = ${ Eq.derived[T] }
</code></pre> 
    <p>Note, that we use inline method syntax and we can compare instance such as <code>Sm(Person("Test", 23)) === Sm(Person("Test", 24))</code> for e.g., the following two types:</p> 
    <pre><code class="language-scala">case class Person(name: String, age: Int)

enum Opt[+T] {
  case Sm(t: T)
  case Nn
}
</code></pre> 
    <p>The full code is shown below:</p> 
    <pre><code class="language-scala">import scala.deriving._
import scala.quoted._
import scala.quoted.matching._

trait Eq[T] {
  def eqv(x: T, y: T): Boolean
}

object Eq {
  given Eq[String] {
    def eqv(x: String, y: String) = x == y
  }

  given Eq[Int] {
    def eqv(x: Int, y: Int) = x == y
  }

  def eqProduct[T](body: (T, T) =&gt; Boolean): Eq[T] =
    new Eq[T] {
      def eqv(x: T, y: T): Boolean = body(x, y)
    }

  def eqSum[T](body: (T, T) =&gt; Boolean): Eq[T] =
    new Eq[T] {
      def eqv(x: T, y: T): Boolean = body(x, y)
    }

  def summonAll[T](t: Type[T])(using qctx: QuoteContext): List[Expr[Eq[_]]] = t match {
    case '[String *: $tpes] =&gt; '{ summon[Eq[String]] }  :: summonAll(tpes)
    case '[Int *: $tpes]    =&gt; '{ summon[Eq[Int]] }     :: summonAll(tpes)
    case '[$tpe *: $tpes]   =&gt; derived(using tpe, qctx) :: summonAll(tpes)
    case '[EmptyTuple] =&gt; Nil
  }

  given derived[T: Type](using qctx: QuoteContext) as Expr[Eq[T]] = {
    import qctx.reflect._

    val ev: Expr[Mirror.Of[T]] = Expr.summon(using '[Mirror.Of[T]]).get

    ev match {
      case '{ $m: Mirror.ProductOf[T] { type MirroredElemTypes = $elementTypes }} =&gt;
        val elemInstances = summonAll(elementTypes)
        val eqProductBody: (Expr[T], Expr[T]) =&gt; Expr[Boolean] = (x, y) =&gt; {
          elemInstances.zipWithIndex.foldLeft(Expr(true: Boolean)) {
            case (acc, (elem, index)) =&gt;
              val e1 = '{$x.asInstanceOf[Product].productElement(${Expr(index)})}
              val e2 = '{$y.asInstanceOf[Product].productElement(${Expr(index)})}

              '{ $acc &amp;&amp; $elem.asInstanceOf[Eq[Any]].eqv($e1, $e2) }
          }
        }
        '{
          eqProduct((x: T, y: T) =&gt; ${eqProductBody('x, 'y)})
        }

      case '{ $m: Mirror.SumOf[T] { type MirroredElemTypes = $elementTypes }} =&gt;
        val elemInstances = summonAll(elementTypes)
        val eqSumBody: (Expr[T], Expr[T]) =&gt; Expr[Boolean] = (x, y) =&gt; {
          val ordx = '{ $m.ordinal($x) }
          val ordy = '{ $m.ordinal($y) }

          val elements = Expr.ofList(elemInstances)
          '{
              $ordx == $ordy &amp;&amp; $elements($ordx).asInstanceOf[Eq[Any]].eqv($x, $y)
          }
        }

        '{
          eqSum((x: T, y: T) =&gt; ${eqSumBody('x, 'y)})
        }
    }
  }
}

object Macro3 {
  extension [T](x: =&gt;T)
    inline def === (y: =&gt;T)(using eq: Eq[T]): Boolean = eq.eqv(x, y)

  implicit inline def eqGen[T]: Eq[T] = ${ Eq.derived[T] }
}
</code></pre> 
   </main> 
  </div> 
  <script>
  ((window.gitter = {}).chat = {}).options = {
    room: 'lampepfl/dotty'
  };
</script> 
  <script src="https://sidecar.gitter.im/dist/sidecar.v1.js" async defer></script>
 </body>
</html>  </div>
</main><footer><span class="go-to-top-icon"><a href="#container"><span class="icon-vertical_align_top"></span>&nbsp;Back to top</a></span><span class="pull-right">Generated by&nbsp;<a href="https://github.com/lampepfl/scala3doc">Scala3doc</a></span></footer></div></div><script type="text/javascript" src="../scripts/pages.js"></script><script type="text/javascript" src="../scripts/main.js"></script></body></html>
