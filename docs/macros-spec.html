<html><head><meta charset="utf-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><title>Macros Spec</title><script type="text/javascript" src="../scripts/clipboard.js" defer="true"></script><script type="text/javascript" src="../scripts/platform-content-handler.js" defer="true"></script><script type="text/javascript" src="../scripts/main.js" defer="true"></script><link rel="stylesheet" href="../styles/nord-light.css"></link><link rel="stylesheet" href="../styles/scalastyle.css"></link><link rel="stylesheet" href="../styles/dotty-icons.css"></link><link rel="stylesheet" href="../styles/diagram.css"></link><link rel="stylesheet" href="../styles/filter-bar.css"></link><link rel="stylesheet" href="../styles/search-bar.css"></link><script type="text/javascript" src="https://code.jquery.com/jquery-3.5.1.min.js" defer="true"></script><script type="text/javascript" src="https://d3js.org/d3.v6.min.js" defer="true"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/graphlib-dot@0.6.2/dist/graphlib-dot.min.js" defer="true"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/dagre-d3/0.6.1/dagre-d3.min.js" defer="true"></script><script type="text/javascript" src="../scripts/diagram.js" defer="true"></script><link rel="stylesheet" href="../styles/filter-bar.css"></link><script type="text/javascript" src="../hljs/highlight.pack.js" defer="true"></script><script type="text/javascript" src="../scripts/hljs-scala3.js" defer="true"></script><script type="text/javascript" src="../scripts/ux.js" defer="true"></script><script type="text/javascript" src="../scripts/common/component.js" defer="true"></script><script type="text/javascript" src="../scripts/common/utils.js" defer="true"></script><script type="text/javascript" src="../scripts/components/FilterBar.js" defer="true"></script><script type="text/javascript" src="../scripts/components/DocumentableList.js" defer="true"></script><script type="text/javascript" src="../scripts/components/Input.js" defer="true"></script><script type="text/javascript" src="../scripts/components/FilterGroup.js" defer="true"></script><script type="text/javascript" src="../scripts/components/Filter.js" defer="true"></script><script type="text/javascript" src="../scripts/data.js" defer="true"></script><script type="text/javascript" src="../scripts/fast-navigation-loader.js" defer="true"></script><link rel="stylesheet" href="../css/bootstrap.min.css"></link><link rel="stylesheet" href="../css/dottydoc.css"></link><link rel="stylesheet" href="../css/color-brewer.css"></link><script type="text/javascript" src="../js/jquery.min.js" defer="true"></script><script type="text/javascript" src="../js/bootstrap.min.js" defer="true"></script><script>var pathToRoot = "../";</script></head><body><div id="container"><div id="leftColumn"><div id="logo"></div><div id="paneSearch"></div><nav id="sideMenu"></nav></div><div id="main"><div id="leftToggler"><span class="icon-toggler"></span></div><div id="searchBar"></div><main>
  <div id="content" pageIds="_.docs/reference/metaprogramming/macros-spec.md////PointingToDeclaration//-1542669386">
    <div class="breadcrumbs"><a href="index.html"></a>/<a href="macros-spec.html">Macros Spec</a></div>
<html>
 <head>
  <link rel="dns-prefetch" href="//fonts.googleapis.com"> 
  <link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin> 
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin> 
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.9.0/css/all.min.css"> 
 </head>
 <body>
  <div id="content-wrapper"> 
   <main class="container"> 
    <header> 
     <h1>"Macros Spec"</h1> 
     <div class="byline"> <a href="/edit/master//"> <i class="far fa-edit"></i> Edit this page on GitHub </a> 
     </div> 
    </header> 
    <h2>Implementation</h2> 
    <h3>Syntax</h3> 
    <p>Compared to the <a href="../../internals/syntax.md">Dotty reference grammar</a> there are the following syntax changes:</p> 
    <pre><code>SimpleExpr      ::=  ...
                  |  ‘'’ ‘{’ Block ‘}’
                  |  ‘'’ ‘[’ Type ‘]’
                  |  ‘$’ ‘{’ Block ‘}’
SimpleType      ::=  ...
                  |  ‘$’ ‘{’ Block ‘}’
</code></pre> 
    <p>In addition, an identifier <code>$x</code> starting with a <code>$</code> that appears inside a quoted expression or type is treated as a splice <code>${x}</code> and a quoted identifier <code>'x</code> that appears inside a splice is treated as a quote <code>'{x}</code></p> 
    <h3>Implementation in <code>scalac</code></h3> 
    <p>Quotes and splices are primitive forms in the generated abstract syntax trees. Top-level splices are eliminated during macro expansion while typing. On the other hand, top-level quotes are eliminated in an expansion phase <code>PickleQuotes</code> phase (after typing and pickling). PCP checking occurs while preparing the RHS of an inline method for top-level splices and in the <code>Staging</code> phase (after typing and before pickling).</p> 
    <p>Macro-expansion works outside-in. If the outermost scope is a splice, the spliced AST will be evaluated in an interpreter. A call to a previously compiled method can be implemented as a reflective call to that method. With the restrictions on splices that are currently in place that’s all that’s needed. We might allow more interpretation in splices in the future, which would allow us to loosen the restriction. Quotes in spliced, interpreted code are kept as they are, after splices nested in the quotes are expanded.</p> 
    <p>If the outermost scope is a quote, we need to generate code that constructs the quoted tree at run-time. We implement this by serializing the tree as a Tasty structure, which is stored in a string literal. At runtime, an unpickler method is called to deserialize the string into a tree.</p> 
    <p>Splices inside quoted code insert the spliced tree as is, after expanding any quotes in the spliced code recursively.</p> 
    <h2>Formalization</h2> 
    <p>The phase consistency principle can be formalized in a calculus that extends simply-typed lambda calculus with quotes and splices.</p> 
    <h3>Syntax</h3> 
    <p>The syntax of terms, values, and types is given as follows:</p> 
    <pre><code>Terms         t  ::=  x                 variable
                      (x: T) =&gt; t       lambda
                      t t               application
                      't                quote
                      $t                splice

Values        v  ::=  (x: T) =&gt; t       lambda
                      'u                quote

Simple terms  u  ::=  x  |  (x: T) =&gt; u  |  u u  |  't

Types         T  ::=  A                 base type
                      T -&gt; T            function type
                      expr T            quoted
</code></pre> 
    <p>Typing rules are formulated using a stack of environments <code>Es</code>. Individual environments <code>E</code> consist as usual of variable bindings <code>x: T</code>. Environments can be combined using the two combinators <code>'</code> and <code>$</code>.</p> 
    <pre><code>Environment   E  ::=  ()                empty
                      E, x: T

Env. stack    Es ::=  ()                empty
                      E                 simple
                      Es * Es           combined

Separator     *  ::=  '
                      $
</code></pre> 
    <p>The two environment combinators are both associative with left and right identity <code>()</code>.</p> 
    <h3>Operational semantics:</h3> 
    <p>We define a small step reduction relation <code>--&gt;</code> with the following rules:</p> 
    <pre><code>          ((x: T) =&gt; t) v  --&gt;  [x := v]t

                    ${'u}  --&gt;  u

                       t1  --&gt;  t2
                    -----------------
                    e[t1]  --&gt;  e[t2]
</code></pre> 
    <p>The first rule is standard call-by-value beta-reduction. The second rule says that splice and quotes cancel each other out. The third rule is a context rule; it says that reduction is allowed in the hole <code>[ ]</code> position of an evaluation context. Evaluation contexts <code>e</code> and splice evaluation context <code>e_s</code> are defined syntactically as follows:</p> 
    <pre><code>Eval context    e    ::=  [ ]  |  e t  |  v e  |  'e_s[${e}]
Splice context  e_s  ::=  [ ]  |  (x: T) =&gt; e_s  |  e_s t  |  u e_s
</code></pre> 
    <h3>Typing rules</h3> 
    <p>Typing judgments are of the form <code>Es |- t: T</code>. There are two substructural rules which express the fact that quotes and splices cancel each other out:</p> 
    <pre><code>                    Es1 * Es2 |- t: T
               ---------------------------
               Es1 $ E1 ' E2 * Es2 |- t: T


                    Es1 * Es2 |- t: T
               ---------------------------
               Es1 ' E1 $ E2 * Es2 |- t: T
</code></pre> 
    <p>The lambda calculus fragment of the rules is standard, except that we use a stack of environments. The rules only interact with the topmost environment of the stack.</p> 
    <pre><code>                          x: T in E
                        --------------
                        Es * E |- x: T


                    Es * E, x: T1 |- t: T2
                -------------------------------
                Es * E |- (x: T1) =&gt; t: T -&gt; T2


               Es |- t1: T2 -&gt; T    Es |- t2: T2
               ---------------------------------
                      Es |- t1 t2: T
</code></pre> 
    <p>The rules for quotes and splices map between <code>expr T</code> and <code>T</code> by trading <code>'</code> and <code>$</code> between environments and terms.</p> 
    <pre><code>                     Es $ () |- t: expr T
                     --------------------
                         Es |- $t: T


                       Es ' () |- t: T
                       ----------------
                       Es |- 't: expr T
</code></pre> 
    <p>The meta theory of a slightly simplified variant 2-stage variant of this calculus is studied <a href="./simple-smp.md">separately</a>.</p> 
    <h2>Going Further</h2> 
    <p>The metaprogramming framework as presented and currently implemented is quite restrictive in that it does not allow for the inspection of quoted expressions and types. It’s possible to work around this by providing all necessary information as normal, unquoted inline parameters. But we would gain more flexibility by allowing for the inspection of quoted code with pattern matching. This opens new possibilities. For instance, here is a version of <code>power</code> that generates the multiplications directly if the exponent is statically known and falls back to the dynamic implementation of power otherwise.</p> 
    <pre><code class="language-scala">inline def power(n: Int, x: Double): Double = ${
  'n match {
    case Constant(n1) =&gt; powerCode(n1, 'x)
    case _ =&gt; '{ dynamicPower(n, x) }
  }
}

private def dynamicPower(n: Int, x: Double): Double =
  if (n == 0) 1.0
  else if (n % 2 == 0) dynamicPower(n / 2, x * x)
  else x * dynamicPower(n - 1, x)
</code></pre> 
    <hr> 
    <p>This assumes a <code>Constant</code> extractor that maps tree nodes representing constants to their values.</p> 
    <p>With the right extractors, the "AsFunction" conversion that maps expressions over functions to functions over expressions can be implemented in user code:</p> 
    <pre><code class="language-scala">given AsFunction1[T, U] as Conversion[Expr[T =&gt; U], Expr[T] =&gt; Expr[U]] {
  def apply(f: Expr[T =&gt; U]): Expr[T] =&gt; Expr[U] =
   (x: Expr[T]) =&gt; f match {
     case Lambda(g) =&gt; g(x)
     case _ =&gt; '{ ($f)($x) }
   }
}
</code></pre> 
    <p>This assumes an extractor</p> 
    <pre><code class="language-scala">object Lambda {
  def unapply[T, U](x: Expr[T =&gt; U]): Option[Expr[T] =&gt; Expr[U]]
}
</code></pre> 
    <p>Once we allow inspection of code via extractors, it’s tempting to also add constructors that create typed trees directly without going through quotes. Most likely, those constructors would work over <code>Expr</code> types which lack a known type argument. For instance, an <code>Apply</code> constructor could be typed as follows:</p> 
    <pre><code class="language-scala">def Apply(fn: Expr[Any], args: List[Expr[Any]]): Expr[Any]
</code></pre> 
    <p>This would allow constructing applications from lists of arguments without having to match the arguments one-by-one with the corresponding formal parameter types of the function. We then need "at the end" a method to convert an <code>Expr[Any]</code> to an <code>Expr[T]</code> where <code>T</code> is given from the outside. E.g. if <code>code</code> yields a <code>Expr[Any]</code>, then <code>code.atType[T]</code> yields an <code>Expr[T]</code>. The <code>atType</code> method has to be implemented as a primitive; it would check that the computed type structure of <code>Expr</code> is a subtype of the type structure representing <code>T</code>.</p> 
    <p>Before going down that route, we should evaluate in detail the tradeoffs it presents. Constructing trees that are only verified <em>a posteriori</em> to be type correct loses a lot of guidance for constructing the right trees. So we should wait with this addition until we have more use-cases that help us decide whether the loss in type-safety is worth the gain in flexibility. In this context, it seems that deconstructing types is less error-prone than deconstructing terms, so one might also envisage a solution that allows the former but not the latter.</p> 
    <h2>Conclusion</h2> 
    <p>Metaprogramming has a reputation of being difficult and confusing. But with explicit <code>Expr/Type</code> types and quotes and splices it can become downright pleasant. A simple strategy first defines the underlying quoted or unquoted values using <code>Expr</code> and <code>Type</code> and then inserts quotes and splices to make the types line up. Phase consistency is at the same time a great guideline where to insert a splice or a quote and a vital sanity check that the result makes sense.</p> 
   </main> 
  </div> 
  <script>
  ((window.gitter = {}).chat = {}).options = {
    room: 'lampepfl/dotty'
  };
</script> 
  <script src="https://sidecar.gitter.im/dist/sidecar.v1.js" async defer></script>
 </body>
</html>  </div>
</main><footer><span class="go-to-top-icon"><a href="#container"><span class="icon-vertical_align_top"></span>&nbsp;Back to top</a></span><span class="pull-right">Generated by&nbsp;<a href="https://github.com/lampepfl/scala3doc">Scala3doc</a></span></footer></div></div><script type="text/javascript" src="../scripts/pages.js"></script><script type="text/javascript" src="../scripts/main.js"></script></body></html>
